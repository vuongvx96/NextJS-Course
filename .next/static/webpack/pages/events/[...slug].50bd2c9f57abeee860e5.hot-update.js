webpackHotUpdate_N_E("pages/events/[...slug]",{

/***/ "./node_modules/dequal/lite/index.mjs":
/*!********************************************!*\
  !*** ./node_modules/dequal/lite/index.mjs ***!
  \********************************************/
/*! exports provided: dequal */
/***/ (function(__webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "dequal", function() { return dequal; });
var has = Object.prototype.hasOwnProperty;

function dequal(foo, bar) {
	var ctor, len;
	if (foo === bar) return true;

	if (foo && bar && (ctor=foo.constructor) === bar.constructor) {
		if (ctor === Date) return foo.getTime() === bar.getTime();
		if (ctor === RegExp) return foo.toString() === bar.toString();

		if (ctor === Array) {
			if ((len=foo.length) === bar.length) {
				while (len-- && dequal(foo[len], bar[len]));
			}
			return len === -1;
		}

		if (!ctor || typeof foo === 'object') {
			len = 0;
			for (ctor in foo) {
				if (has.call(foo, ctor) && ++len && !has.call(bar, ctor)) return false;
				if (!(ctor in bar) || !dequal(foo[ctor], bar[ctor])) return false;
			}
			return Object.keys(bar).length === len;
		}
	}

	return foo !== foo && bar !== bar;
}


/***/ }),

/***/ "./node_modules/swr/esm/cache.js":
/*!***************************************!*\
  !*** ./node_modules/swr/esm/cache.js ***!
  \***************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _libs_hash__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./libs/hash */ "./node_modules/swr/esm/libs/hash.js");

var Cache = /** @class */ (function () {
    function Cache(initialData) {
        if (initialData === void 0) { initialData = {}; }
        this.cache = new Map(Object.entries(initialData));
        this.subs = [];
    }
    Cache.prototype.get = function (key) {
        var _key = this.serializeKey(key)[0];
        return this.cache.get(_key);
    };
    Cache.prototype.set = function (key, value) {
        var _key = this.serializeKey(key)[0];
        this.cache.set(_key, value);
        this.notify();
    };
    Cache.prototype.keys = function () {
        return Array.from(this.cache.keys());
    };
    Cache.prototype.has = function (key) {
        var _key = this.serializeKey(key)[0];
        return this.cache.has(_key);
    };
    Cache.prototype.clear = function () {
        this.cache.clear();
        this.notify();
    };
    Cache.prototype.delete = function (key) {
        var _key = this.serializeKey(key)[0];
        this.cache.delete(_key);
        this.notify();
    };
    // TODO: introduce namespace for the cache
    Cache.prototype.serializeKey = function (key) {
        var args = null;
        if (typeof key === 'function') {
            try {
                key = key();
            }
            catch (err) {
                // dependencies not ready
                key = '';
            }
        }
        if (Array.isArray(key)) {
            // args array
            args = key;
            key = Object(_libs_hash__WEBPACK_IMPORTED_MODULE_0__["default"])(key);
        }
        else {
            // convert null to ''
            key = String(key || '');
        }
        var errorKey = key ? 'err@' + key : '';
        var isValidatingKey = key ? 'validating@' + key : '';
        return [key, args, errorKey, isValidatingKey];
    };
    Cache.prototype.subscribe = function (listener) {
        var _this = this;
        if (typeof listener !== 'function') {
            throw new Error('Expected the listener to be a function.');
        }
        var isSubscribed = true;
        this.subs.push(listener);
        return function () {
            if (!isSubscribed)
                return;
            isSubscribed = false;
            var index = _this.subs.indexOf(listener);
            if (index > -1) {
                _this.subs[index] = _this.subs[_this.subs.length - 1];
                _this.subs.length--;
            }
        };
    };
    // Notify Cache subscribers about a change in the cache
    Cache.prototype.notify = function () {
        for (var _i = 0, _a = this.subs; _i < _a.length; _i++) {
            var listener = _a[_i];
            listener();
        }
    };
    return Cache;
}());
/* harmony default export */ __webpack_exports__["default"] = (Cache);


/***/ }),

/***/ "./node_modules/swr/esm/config.js":
/*!****************************************!*\
  !*** ./node_modules/swr/esm/config.js ***!
  \****************************************/
/*! exports provided: cache, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "cache", function() { return cache; });
/* harmony import */ var dequal_lite__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! dequal/lite */ "./node_modules/dequal/lite/index.mjs");
/* harmony import */ var _cache__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./cache */ "./node_modules/swr/esm/cache.js");
/* harmony import */ var _libs_web_preset__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./libs/web-preset */ "./node_modules/swr/esm/libs/web-preset.js");
var __assign = (undefined && undefined.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};



// cache
var cache = new _cache__WEBPACK_IMPORTED_MODULE_1__["default"]();
// error retry
function onErrorRetry(_, __, config, revalidate, opts) {
    if (!config.isDocumentVisible()) {
        // if it's hidden, stop
        // it will auto revalidate when focus
        return;
    }
    if (typeof config.errorRetryCount === 'number' &&
        opts.retryCount > config.errorRetryCount) {
        return;
    }
    // exponential backoff
    var count = Math.min(opts.retryCount, 8);
    var timeout = ~~((Math.random() + 0.5) * (1 << count)) * config.errorRetryInterval;
    setTimeout(revalidate, timeout, opts);
}
// client side: need to adjust the config
// based on the browser status
// slow connection (<= 70Kbps)
var slowConnection = typeof window !== 'undefined' &&
    // @ts-ignore
    navigator['connection'] &&
    // @ts-ignore
    ['slow-2g', '2g'].indexOf(navigator['connection'].effectiveType) !== -1;
// config
var defaultConfig = __assign({ 
    // events
    onLoadingSlow: function () { }, onSuccess: function () { }, onError: function () { }, onErrorRetry: onErrorRetry, errorRetryInterval: (slowConnection ? 10 : 5) * 1000, focusThrottleInterval: 5 * 1000, dedupingInterval: 2 * 1000, loadingTimeout: (slowConnection ? 5 : 3) * 1000, refreshInterval: 0, revalidateOnFocus: true, revalidateOnReconnect: true, refreshWhenHidden: false, refreshWhenOffline: false, shouldRetryOnError: true, suspense: false, compare: dequal_lite__WEBPACK_IMPORTED_MODULE_0__["dequal"], isPaused: function () { return false; } }, _libs_web_preset__WEBPACK_IMPORTED_MODULE_2__["default"]);

/* harmony default export */ __webpack_exports__["default"] = (defaultConfig);


/***/ }),

/***/ "./node_modules/swr/esm/env.js":
/*!*************************************!*\
  !*** ./node_modules/swr/esm/env.js ***!
  \*************************************/
/*! exports provided: IS_SERVER, rAF, useIsomorphicLayoutEffect */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "IS_SERVER", function() { return IS_SERVER; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "rAF", function() { return rAF; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "useIsomorphicLayoutEffect", function() { return useIsomorphicLayoutEffect; });
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ "./node_modules/react/index.js");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);

var IS_SERVER = typeof window === 'undefined' ||
    // @ts-ignore
    !!(typeof Deno !== 'undefined' && Deno && Deno.version && Deno.version.deno);
// polyfill for requestAnimationFrame
var rAF = IS_SERVER
    ? null
    : window['requestAnimationFrame']
        ? function (f) { return window['requestAnimationFrame'](f); }
        : function (f) { return setTimeout(f, 1); };
// React currently throws a warning when using useLayoutEffect on the server.
// To get around it, we can conditionally useEffect on the server (no-op) and
// useLayoutEffect in the browser.
var useIsomorphicLayoutEffect = IS_SERVER ? react__WEBPACK_IMPORTED_MODULE_0__["useEffect"] : react__WEBPACK_IMPORTED_MODULE_0__["useLayoutEffect"];


/***/ }),

/***/ "./node_modules/swr/esm/index.js":
/*!***************************************!*\
  !*** ./node_modules/swr/esm/index.js ***!
  \***************************************/
/*! exports provided: default, trigger, mutate, SWRConfig, useSWRInfinite, cache */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _use_swr__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./use-swr */ "./node_modules/swr/esm/use-swr.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "trigger", function() { return _use_swr__WEBPACK_IMPORTED_MODULE_0__["trigger"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "mutate", function() { return _use_swr__WEBPACK_IMPORTED_MODULE_0__["mutate"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "SWRConfig", function() { return _use_swr__WEBPACK_IMPORTED_MODULE_0__["SWRConfig"]; });

/* harmony import */ var _use_swr_infinite__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./use-swr-infinite */ "./node_modules/swr/esm/use-swr-infinite.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "useSWRInfinite", function() { return _use_swr_infinite__WEBPACK_IMPORTED_MODULE_1__["useSWRInfinite"]; });

/* harmony import */ var _config__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./config */ "./node_modules/swr/esm/config.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "cache", function() { return _config__WEBPACK_IMPORTED_MODULE_2__["cache"]; });

// `useSWR` and related APIs

/* harmony default export */ __webpack_exports__["default"] = (_use_swr__WEBPACK_IMPORTED_MODULE_0__["default"]);

// `useSWRInfinite`

// Cache related, to be replaced by the new APIs



/***/ }),

/***/ "./node_modules/swr/esm/libs/hash.js":
/*!*******************************************!*\
  !*** ./node_modules/swr/esm/libs/hash.js ***!
  \*******************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return hash; });
// use WeakMap to store the object->key mapping
// so the objects can be garbage collected.
// WeakMap uses a hashtable under the hood, so the lookup
// complexity is almost O(1).
var table = new WeakMap();
// counter of the key
var counter = 0;
// hashes an array of objects and returns a string
function hash(args) {
    if (!args.length)
        return '';
    var key = 'arg';
    for (var i = 0; i < args.length; ++i) {
        if (args[i] === null) {
            key += '@null';
            continue;
        }
        var _hash = void 0;
        if (typeof args[i] !== 'object' && typeof args[i] !== 'function') {
            // need to consider the case that args[i] is a string:
            // args[i]        _hash
            // "undefined" -> '"undefined"'
            // undefined   -> 'undefined'
            // 123         -> '123'
            // "null"      -> '"null"'
            if (typeof args[i] === 'string') {
                _hash = '"' + args[i] + '"';
            }
            else {
                _hash = String(args[i]);
            }
        }
        else {
            if (!table.has(args[i])) {
                _hash = counter;
                table.set(args[i], counter++);
            }
            else {
                _hash = table.get(args[i]);
            }
        }
        key += '@' + _hash;
    }
    return key;
}


/***/ }),

/***/ "./node_modules/swr/esm/libs/web-preset.js":
/*!*************************************************!*\
  !*** ./node_modules/swr/esm/libs/web-preset.js ***!
  \*************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/**
 * Due to bug https://bugs.chromium.org/p/chromium/issues/detail?id=678075,
 * it's not reliable to detect if the browser is currently online or offline
 * based on `navigator.onLine`.
 * As a work around, we always assume it's online on first load, and change
 * the status upon `online` or `offline` events.
 */
var online = true;
var isOnline = function () { return online; };
var isDocumentVisible = function () {
    if (typeof document !== 'undefined' &&
        document.visibilityState !== undefined) {
        return document.visibilityState !== 'hidden';
    }
    // always assume it's visible
    return true;
};
var fetcher = function (url) { return fetch(url).then(function (res) { return res.json(); }); };
var registerOnFocus = function (cb) {
    if (typeof window !== 'undefined' &&
        window.addEventListener !== undefined &&
        typeof document !== 'undefined' &&
        document.addEventListener !== undefined) {
        // focus revalidate
        document.addEventListener('visibilitychange', function () { return cb(); }, false);
        window.addEventListener('focus', function () { return cb(); }, false);
    }
};
var registerOnReconnect = function (cb) {
    if (typeof window !== 'undefined' && window.addEventListener !== undefined) {
        // reconnect revalidate
        window.addEventListener('online', function () {
            online = true;
            cb();
        }, false);
        // nothing to revalidate, just update the status
        window.addEventListener('offline', function () { return (online = false); }, false);
    }
};
/* harmony default export */ __webpack_exports__["default"] = ({
    isOnline: isOnline,
    isDocumentVisible: isDocumentVisible,
    fetcher: fetcher,
    registerOnFocus: registerOnFocus,
    registerOnReconnect: registerOnReconnect
});


/***/ }),

/***/ "./node_modules/swr/esm/swr-config-context.js":
/*!****************************************************!*\
  !*** ./node_modules/swr/esm/swr-config-context.js ***!
  \****************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ "./node_modules/react/index.js");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);

var SWRConfigContext = Object(react__WEBPACK_IMPORTED_MODULE_0__["createContext"])({});
SWRConfigContext.displayName = 'SWRConfigContext';
/* harmony default export */ __webpack_exports__["default"] = (SWRConfigContext);


/***/ }),

/***/ "./node_modules/swr/esm/use-swr-infinite.js":
/*!**************************************************!*\
  !*** ./node_modules/swr/esm/use-swr-infinite.js ***!
  \**************************************************/
/*! exports provided: useSWRInfinite */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "useSWRInfinite", function() { return useSWRInfinite; });
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ "./node_modules/react/index.js");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _config__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./config */ "./node_modules/swr/esm/config.js");
/* harmony import */ var _env__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./env */ "./node_modules/swr/esm/env.js");
/* harmony import */ var _swr_config_context__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./swr-config-context */ "./node_modules/swr/esm/swr-config-context.js");
/* harmony import */ var _use_swr__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./use-swr */ "./node_modules/swr/esm/use-swr.js");
var __awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (undefined && undefined.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
var __rest = (undefined && undefined.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
// TODO: use @ts-expect-error





function useSWRInfinite() {
    var _this = this;
    var args = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        args[_i] = arguments[_i];
    }
    var getKey = args[0];
    var config = Object.assign({}, _config__WEBPACK_IMPORTED_MODULE_1__["default"], Object(react__WEBPACK_IMPORTED_MODULE_0__["useContext"])(_swr_config_context__WEBPACK_IMPORTED_MODULE_3__["default"]), args.length > 2
        ? args[2]
        : args.length === 2 && typeof args[1] === 'object'
            ? args[1]
            : {});
    // in typescript args.length > 2 is not same as args.lenth === 3
    // we do a safe type assertion here
    // args.length === 3
    var fn = (args.length > 2
        ? args[1]
        : args.length === 2 && typeof args[1] === 'function'
            ? args[1]
            : config.fetcher);
    var _a = config.initialSize, initialSize = _a === void 0 ? 1 : _a, _b = config.revalidateAll, revalidateAll = _b === void 0 ? false : _b, _c = config.persistSize, persistSize = _c === void 0 ? false : _c, extraConfig = __rest(config
    // get the serialized key of the first page
    , ["initialSize", "revalidateAll", "persistSize"]);
    // get the serialized key of the first page
    var firstPageKey = null;
    try {
        ;
        firstPageKey = _config__WEBPACK_IMPORTED_MODULE_1__["cache"].serializeKey(getKey(0, null))[0];
    }
    catch (err) {
        // not ready
    }
    var rerender = Object(react__WEBPACK_IMPORTED_MODULE_0__["useState"])({})[1];
    // we use cache to pass extra info (context) to fetcher so it can be globally shared
    // here we get the key of the fetcher context cache
    var contextCacheKey = null;
    if (firstPageKey) {
        contextCacheKey = 'ctx@' + firstPageKey;
    }
    // page size is also cached to share the page data between hooks having the same key
    var pageSizeCacheKey = null;
    if (firstPageKey) {
        pageSizeCacheKey = 'len@' + firstPageKey;
    }
    var didMountRef = Object(react__WEBPACK_IMPORTED_MODULE_0__["useRef"])(false);
    var resolvePageSize = Object(react__WEBPACK_IMPORTED_MODULE_0__["useCallback"])(function () {
        var cachedPageSize = _config__WEBPACK_IMPORTED_MODULE_1__["cache"].get(pageSizeCacheKey);
        return typeof cachedPageSize !== 'undefined' ? cachedPageSize : initialSize;
    }, [pageSizeCacheKey, initialSize]);
    // keep the last page size to restore it with the persistSize option
    var lastPageSizeRef = Object(react__WEBPACK_IMPORTED_MODULE_0__["useRef"])(resolvePageSize());
    // every time the key changes, we reset the page size if it's not persisted
    Object(_env__WEBPACK_IMPORTED_MODULE_2__["useIsomorphicLayoutEffect"])(function () {
        if (!didMountRef.current) {
            didMountRef.current = true;
            return;
        }
        // If the key has been changed, we keep the current page size if persistSize is enabled
        _config__WEBPACK_IMPORTED_MODULE_1__["cache"].set(pageSizeCacheKey, persistSize ? lastPageSizeRef.current : initialSize);
        // initialSize isn't allowed to change during the lifecycle
        // eslint-disable-next-line react-hooks/exhaustive-deps
    }, [firstPageKey]);
    // keep the data inside a ref
    var dataRef = Object(react__WEBPACK_IMPORTED_MODULE_0__["useRef"])();
    // actual swr of all pages
    var swr = Object(_use_swr__WEBPACK_IMPORTED_MODULE_4__["default"])(firstPageKey ? ['inf', firstPageKey] : null, function () { return __awaiter(_this, void 0, void 0, function () {
        var _a, originalData, force, data, pageSize, previousPageData, i, _b, pageKey, pageArgs, pageData, shouldFetchPage;
        return __generator(this, function (_c) {
            switch (_c.label) {
                case 0:
                    _a = _config__WEBPACK_IMPORTED_MODULE_1__["cache"].get(contextCacheKey) || {}, originalData = _a.data, force = _a.force;
                    data = [];
                    pageSize = resolvePageSize();
                    previousPageData = null;
                    i = 0;
                    _c.label = 1;
                case 1:
                    if (!(i < pageSize)) return [3 /*break*/, 8];
                    _b = _config__WEBPACK_IMPORTED_MODULE_1__["cache"].serializeKey(getKey(i, previousPageData)), pageKey = _b[0], pageArgs = _b[1];
                    if (!pageKey) {
                        // pageKey is falsy, stop fetching next pages
                        return [3 /*break*/, 8];
                    }
                    pageData = _config__WEBPACK_IMPORTED_MODULE_1__["cache"].get(pageKey);
                    shouldFetchPage = revalidateAll ||
                        force ||
                        typeof pageData === 'undefined' ||
                        (typeof force === 'undefined' &&
                            i === 0 &&
                            typeof dataRef.current !== 'undefined') ||
                        (originalData && !config.compare(originalData[i], pageData));
                    if (!shouldFetchPage) return [3 /*break*/, 6];
                    if (!(pageArgs !== null)) return [3 /*break*/, 3];
                    return [4 /*yield*/, fn.apply(void 0, pageArgs)];
                case 2:
                    pageData = _c.sent();
                    return [3 /*break*/, 5];
                case 3: return [4 /*yield*/, fn(pageKey)];
                case 4:
                    pageData = _c.sent();
                    _c.label = 5;
                case 5:
                    _config__WEBPACK_IMPORTED_MODULE_1__["cache"].set(pageKey, pageData);
                    _c.label = 6;
                case 6:
                    data.push(pageData);
                    previousPageData = pageData;
                    _c.label = 7;
                case 7:
                    ++i;
                    return [3 /*break*/, 1];
                case 8:
                    // once we executed the data fetching based on the context, clear the context
                    _config__WEBPACK_IMPORTED_MODULE_1__["cache"].delete(contextCacheKey);
                    // return the data
                    return [2 /*return*/, data];
            }
        });
    }); }, extraConfig);
    // update dataRef
    Object(_env__WEBPACK_IMPORTED_MODULE_2__["useIsomorphicLayoutEffect"])(function () {
        dataRef.current = swr.data;
    }, [swr.data]);
    var mutate = Object(react__WEBPACK_IMPORTED_MODULE_0__["useCallback"])(function (data, shouldRevalidate) {
        if (shouldRevalidate === void 0) { shouldRevalidate = true; }
        if (shouldRevalidate && typeof data !== 'undefined') {
            // we only revalidate the pages that are changed
            var originalData = dataRef.current;
            _config__WEBPACK_IMPORTED_MODULE_1__["cache"].set(contextCacheKey, { data: originalData, force: false });
        }
        else if (shouldRevalidate) {
            // calling `mutate()`, we revalidate all pages
            _config__WEBPACK_IMPORTED_MODULE_1__["cache"].set(contextCacheKey, { force: true });
        }
        return swr.mutate(data, shouldRevalidate);
    }, 
    // swr.mutate is always the same reference
    // eslint-disable-next-line react-hooks/exhaustive-deps
    [contextCacheKey]);
    // extend the SWR API
    var setSize = Object(react__WEBPACK_IMPORTED_MODULE_0__["useCallback"])(function (arg) {
        var size;
        if (typeof arg === 'function') {
            size = arg(resolvePageSize());
        }
        else if (typeof arg === 'number') {
            size = arg;
        }
        if (typeof size === 'number') {
            _config__WEBPACK_IMPORTED_MODULE_1__["cache"].set(pageSizeCacheKey, size);
            lastPageSizeRef.current = size;
        }
        rerender({});
        return mutate(function (v) { return v; });
    }, 
    // immutability of rerender is guaranteed by React, but react-hooks/exhaustive-deps doesn't recognize it
    // from `rerender = useState({})[1], so we put rerender here
    [pageSizeCacheKey, resolvePageSize, mutate, rerender]);
    // Use getter functions to avoid unnecessary re-renders caused by triggering all the getters of the returned swr object
    var swrInfinite = { size: resolvePageSize(), setSize: setSize, mutate: mutate };
    Object.defineProperties(swrInfinite, {
        error: {
            get: function () { return swr.error; },
            enumerable: true
        },
        data: {
            get: function () { return swr.data; },
            enumerable: true
        },
        // revalidate will be deprecated in the 1.x release
        // because mutate() covers the same use case of revalidate().
        // This remains only for backward compatibility
        revalidate: {
            get: function () { return swr.revalidate; },
            enumerable: true
        },
        isValidating: {
            get: function () { return swr.isValidating; },
            enumerable: true
        }
    });
    return swrInfinite;
}



/***/ }),

/***/ "./node_modules/swr/esm/use-swr.js":
/*!*****************************************!*\
  !*** ./node_modules/swr/esm/use-swr.js ***!
  \*****************************************/
/*! exports provided: trigger, mutate, SWRConfig, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "trigger", function() { return trigger; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "mutate", function() { return mutate; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SWRConfig", function() { return SWRConfig; });
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ "./node_modules/react/index.js");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _config__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./config */ "./node_modules/swr/esm/config.js");
/* harmony import */ var _env__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./env */ "./node_modules/swr/esm/env.js");
/* harmony import */ var _swr_config_context__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./swr-config-context */ "./node_modules/swr/esm/swr-config-context.js");
var __awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (undefined && undefined.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
// TODO: use @ts-expect-error




// global state managers
var CONCURRENT_PROMISES = {};
var CONCURRENT_PROMISES_TS = {};
var FOCUS_REVALIDATORS = {};
var RECONNECT_REVALIDATORS = {};
var CACHE_REVALIDATORS = {};
var MUTATION_TS = {};
var MUTATION_END_TS = {};
// generate strictly increasing timestamps
var now = (function () {
    var ts = 0;
    return function () { return ++ts; };
})();
// setup DOM events listeners for `focus` and `reconnect` actions
if (!_env__WEBPACK_IMPORTED_MODULE_2__["IS_SERVER"]) {
    var revalidate_1 = function (revalidators) {
        if (!_config__WEBPACK_IMPORTED_MODULE_1__["default"].isDocumentVisible() || !_config__WEBPACK_IMPORTED_MODULE_1__["default"].isOnline())
            return;
        for (var key in revalidators) {
            if (revalidators[key][0])
                revalidators[key][0]();
        }
    };
    if (typeof _config__WEBPACK_IMPORTED_MODULE_1__["default"].registerOnFocus === 'function') {
        _config__WEBPACK_IMPORTED_MODULE_1__["default"].registerOnFocus(function () { return revalidate_1(FOCUS_REVALIDATORS); });
    }
    if (typeof _config__WEBPACK_IMPORTED_MODULE_1__["default"].registerOnReconnect === 'function') {
        _config__WEBPACK_IMPORTED_MODULE_1__["default"].registerOnReconnect(function () { return revalidate_1(RECONNECT_REVALIDATORS); });
    }
}
var trigger = function (_key, shouldRevalidate) {
    if (shouldRevalidate === void 0) { shouldRevalidate = true; }
    // we are ignoring the second argument which correspond to the arguments
    // the fetcher will receive when key is an array
    var _a = _config__WEBPACK_IMPORTED_MODULE_1__["cache"].serializeKey(_key), key = _a[0], keyErr = _a[2], keyValidating = _a[3];
    if (!key)
        return Promise.resolve();
    var updaters = CACHE_REVALIDATORS[key];
    if (key && updaters) {
        var currentData = _config__WEBPACK_IMPORTED_MODULE_1__["cache"].get(key);
        var currentError = _config__WEBPACK_IMPORTED_MODULE_1__["cache"].get(keyErr);
        var currentIsValidating = _config__WEBPACK_IMPORTED_MODULE_1__["cache"].get(keyValidating);
        var promises = [];
        for (var i = 0; i < updaters.length; ++i) {
            promises.push(updaters[i](shouldRevalidate, currentData, currentError, currentIsValidating, i > 0));
        }
        // return new updated value
        return Promise.all(promises).then(function () { return _config__WEBPACK_IMPORTED_MODULE_1__["cache"].get(key); });
    }
    return Promise.resolve(_config__WEBPACK_IMPORTED_MODULE_1__["cache"].get(key));
};
var broadcastState = function (key, data, error, isValidating) {
    var updaters = CACHE_REVALIDATORS[key];
    if (key && updaters) {
        for (var i = 0; i < updaters.length; ++i) {
            updaters[i](false, data, error, isValidating);
        }
    }
};
var mutate = function (_key, _data, shouldRevalidate) {
    if (shouldRevalidate === void 0) { shouldRevalidate = true; }
    return __awaiter(void 0, void 0, void 0, function () {
        var _a, key, keyErr, beforeMutationTs, beforeConcurrentPromisesTs, data, error, isAsyncMutation, err_1, shouldAbort, updaters, promises, i;
        return __generator(this, function (_b) {
            switch (_b.label) {
                case 0:
                    _a = _config__WEBPACK_IMPORTED_MODULE_1__["cache"].serializeKey(_key), key = _a[0], keyErr = _a[2];
                    if (!key)
                        return [2 /*return*/];
                    // if there is no new data to update, let's just revalidate the key
                    if (typeof _data === 'undefined')
                        return [2 /*return*/, trigger(_key, shouldRevalidate)
                            // update global timestamps
                        ];
                    // update global timestamps
                    MUTATION_TS[key] = now() - 1;
                    MUTATION_END_TS[key] = 0;
                    beforeMutationTs = MUTATION_TS[key];
                    beforeConcurrentPromisesTs = CONCURRENT_PROMISES_TS[key];
                    isAsyncMutation = false;
                    if (_data && typeof _data === 'function') {
                        // `_data` is a function, call it passing current cache value
                        try {
                            _data = _data(_config__WEBPACK_IMPORTED_MODULE_1__["cache"].get(key));
                        }
                        catch (err) {
                            // if `_data` function throws an error synchronously, it shouldn't be cached
                            _data = undefined;
                            error = err;
                        }
                    }
                    if (!(_data && typeof _data.then === 'function')) return [3 /*break*/, 5];
                    // `_data` is a promise
                    isAsyncMutation = true;
                    _b.label = 1;
                case 1:
                    _b.trys.push([1, 3, , 4]);
                    return [4 /*yield*/, _data];
                case 2:
                    data = _b.sent();
                    return [3 /*break*/, 4];
                case 3:
                    err_1 = _b.sent();
                    error = err_1;
                    return [3 /*break*/, 4];
                case 4: return [3 /*break*/, 6];
                case 5:
                    data = _data;
                    _b.label = 6;
                case 6:
                    shouldAbort = function () {
                        // check if other mutations have occurred since we've started this mutation
                        if (beforeMutationTs !== MUTATION_TS[key] ||
                            beforeConcurrentPromisesTs !== CONCURRENT_PROMISES_TS[key]) {
                            if (error)
                                throw error;
                            return true;
                        }
                    };
                    // if there's a race we don't update cache or broadcast change, just return the data
                    if (shouldAbort())
                        return [2 /*return*/, data];
                    if (typeof data !== 'undefined') {
                        // update cached data
                        _config__WEBPACK_IMPORTED_MODULE_1__["cache"].set(key, data);
                    }
                    // always update or reset the error
                    _config__WEBPACK_IMPORTED_MODULE_1__["cache"].set(keyErr, error);
                    // reset the timestamp to mark the mutation has ended
                    MUTATION_END_TS[key] = now() - 1;
                    if (!isAsyncMutation) {
                        // we skip broadcasting if there's another mutation happened synchronously
                        if (shouldAbort())
                            return [2 /*return*/, data];
                    }
                    updaters = CACHE_REVALIDATORS[key];
                    if (updaters) {
                        promises = [];
                        for (i = 0; i < updaters.length; ++i) {
                            promises.push(updaters[i](!!shouldRevalidate, data, error, undefined, i > 0));
                        }
                        // return new updated value
                        return [2 /*return*/, Promise.all(promises).then(function () {
                                if (error)
                                    throw error;
                                return _config__WEBPACK_IMPORTED_MODULE_1__["cache"].get(key);
                            })];
                    }
                    // throw error or return data to be used by caller of mutate
                    if (error)
                        throw error;
                    return [2 /*return*/, data];
            }
        });
    });
};
function useSWR() {
    var _this = this;
    var args = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        args[_i] = arguments[_i];
    }
    var _key = args[0];
    var config = Object.assign({}, _config__WEBPACK_IMPORTED_MODULE_1__["default"], Object(react__WEBPACK_IMPORTED_MODULE_0__["useContext"])(_swr_config_context__WEBPACK_IMPORTED_MODULE_3__["default"]), args.length > 2
        ? args[2]
        : args.length === 2 && typeof args[1] === 'object'
            ? args[1]
            : {});
    // in typescript args.length > 2 is not same as args.lenth === 3
    // we do a safe type assertion here
    // args.length === 3
    var fn = (args.length > 2
        ? args[1]
        : args.length === 2 && typeof args[1] === 'function'
            ? args[1]
            : /**
                  pass fn as null will disable revalidate
                  https://paco.sh/blog/shared-hook-state-with-swr
                */
                args[1] === null
                    ? args[1]
                    : config.fetcher);
    // we assume `key` as the identifier of the request
    // `key` can change but `fn` shouldn't
    // (because `revalidate` only depends on `key`)
    // `keyErr` is the cache key for error objects
    var _a = _config__WEBPACK_IMPORTED_MODULE_1__["cache"].serializeKey(_key), key = _a[0], fnArgs = _a[1], keyErr = _a[2], keyValidating = _a[3];
    var configRef = Object(react__WEBPACK_IMPORTED_MODULE_0__["useRef"])(config);
    Object(_env__WEBPACK_IMPORTED_MODULE_2__["useIsomorphicLayoutEffect"])(function () {
        configRef.current = config;
    });
    var willRevalidateOnMount = function () {
        return (config.revalidateOnMount ||
            (!config.initialData && config.revalidateOnMount === undefined));
    };
    var resolveData = function () {
        var cachedData = _config__WEBPACK_IMPORTED_MODULE_1__["cache"].get(key);
        return typeof cachedData === 'undefined' ? config.initialData : cachedData;
    };
    var resolveIsValidating = function () {
        return !!_config__WEBPACK_IMPORTED_MODULE_1__["cache"].get(keyValidating) || (key && willRevalidateOnMount());
    };
    var initialData = resolveData();
    var initialError = _config__WEBPACK_IMPORTED_MODULE_1__["cache"].get(keyErr);
    var initialIsValidating = resolveIsValidating();
    // if a state is accessed (data, error or isValidating),
    // we add the state to dependencies so if the state is
    // updated in the future, we can trigger a rerender
    var stateDependencies = Object(react__WEBPACK_IMPORTED_MODULE_0__["useRef"])({
        data: false,
        error: false,
        isValidating: false
    });
    var stateRef = Object(react__WEBPACK_IMPORTED_MODULE_0__["useRef"])({
        data: initialData,
        error: initialError,
        isValidating: initialIsValidating
    });
    // display the data label in the React DevTools next to SWR hooks
    Object(react__WEBPACK_IMPORTED_MODULE_0__["useDebugValue"])(stateRef.current.data);
    var rerender = Object(react__WEBPACK_IMPORTED_MODULE_0__["useState"])({})[1];
    var dispatch = Object(react__WEBPACK_IMPORTED_MODULE_0__["useCallback"])(function (payload) {
        var shouldUpdateState = false;
        for (var k in payload) {
            // @ts-ignore
            if (stateRef.current[k] === payload[k]) {
                continue;
            }
            // @ts-ignore
            stateRef.current[k] = payload[k];
            // @ts-ignore
            if (stateDependencies.current[k]) {
                shouldUpdateState = true;
            }
        }
        if (shouldUpdateState) {
            // if component is unmounted, should skip rerender
            // if component is not mounted, should skip rerender
            if (unmountedRef.current || !initialMountedRef.current)
                return;
            rerender({});
        }
    }, 
    // config.suspense isn't allowed to change during the lifecycle
    // eslint-disable-next-line react-hooks/exhaustive-deps
    []);
    // error ref inside revalidate (is last request errored?)
    var unmountedRef = Object(react__WEBPACK_IMPORTED_MODULE_0__["useRef"])(false);
    var keyRef = Object(react__WEBPACK_IMPORTED_MODULE_0__["useRef"])(key);
    // check if component is mounted in suspense mode
    var initialMountedRef = Object(react__WEBPACK_IMPORTED_MODULE_0__["useRef"])(false);
    // do unmount check for callbacks
    var eventsCallback = Object(react__WEBPACK_IMPORTED_MODULE_0__["useCallback"])(function (event) {
        var _a;
        var params = [];
        for (var _i = 1; _i < arguments.length; _i++) {
            params[_i - 1] = arguments[_i];
        }
        if (unmountedRef.current)
            return;
        if (!initialMountedRef.current)
            return;
        if (key !== keyRef.current)
            return;
        // @ts-ignore
        (_a = configRef.current)[event].apply(_a, params);
    }, [key]);
    var boundMutate = Object(react__WEBPACK_IMPORTED_MODULE_0__["useCallback"])(function (data, shouldRevalidate) {
        return mutate(keyRef.current, data, shouldRevalidate);
    }, []);
    var addRevalidator = function (revalidators, callback) {
        if (!revalidators[key]) {
            revalidators[key] = [callback];
        }
        else {
            revalidators[key].push(callback);
        }
        return function () {
            var keyedRevalidators = revalidators[key];
            var index = keyedRevalidators.indexOf(callback);
            if (index >= 0) {
                // O(1): faster than splice
                keyedRevalidators[index] =
                    keyedRevalidators[keyedRevalidators.length - 1];
                keyedRevalidators.pop();
            }
        };
    };
    // start a revalidation
    var revalidate = Object(react__WEBPACK_IMPORTED_MODULE_0__["useCallback"])(function (revalidateOpts) {
        if (revalidateOpts === void 0) { revalidateOpts = {}; }
        return __awaiter(_this, void 0, void 0, function () {
            var _a, retryCount, _b, dedupe, loading, shouldDeduping, newData, startAt, newState, err_2;
            return __generator(this, function (_c) {
                switch (_c.label) {
                    case 0:
                        if (!key || !fn)
                            return [2 /*return*/, false];
                        if (unmountedRef.current)
                            return [2 /*return*/, false];
                        if (configRef.current.isPaused())
                            return [2 /*return*/, false];
                        _a = revalidateOpts.retryCount, retryCount = _a === void 0 ? 0 : _a, _b = revalidateOpts.dedupe, dedupe = _b === void 0 ? false : _b;
                        loading = true;
                        shouldDeduping = typeof CONCURRENT_PROMISES[key] !== 'undefined' && dedupe;
                        _c.label = 1;
                    case 1:
                        _c.trys.push([1, 6, , 7]);
                        dispatch({
                            isValidating: true
                        });
                        _config__WEBPACK_IMPORTED_MODULE_1__["cache"].set(keyValidating, true);
                        if (!shouldDeduping) {
                            // also update other hooks
                            broadcastState(key, stateRef.current.data, stateRef.current.error, true);
                        }
                        newData = void 0;
                        startAt = void 0;
                        if (!shouldDeduping) return [3 /*break*/, 3];
                        // there's already an ongoing request,
                        // this one needs to be deduplicated.
                        startAt = CONCURRENT_PROMISES_TS[key];
                        return [4 /*yield*/, CONCURRENT_PROMISES[key]];
                    case 2:
                        newData = _c.sent();
                        return [3 /*break*/, 5];
                    case 3:
                        // if no cache being rendered currently (it shows a blank page),
                        // we trigger the loading slow event.
                        if (config.loadingTimeout && !_config__WEBPACK_IMPORTED_MODULE_1__["cache"].get(key)) {
                            setTimeout(function () {
                                if (loading)
                                    eventsCallback('onLoadingSlow', key, config);
                            }, config.loadingTimeout);
                        }
                        if (fnArgs !== null) {
                            CONCURRENT_PROMISES[key] = fn.apply(void 0, fnArgs);
                        }
                        else {
                            CONCURRENT_PROMISES[key] = fn(key);
                        }
                        CONCURRENT_PROMISES_TS[key] = startAt = now();
                        return [4 /*yield*/, CONCURRENT_PROMISES[key]];
                    case 4:
                        newData = _c.sent();
                        setTimeout(function () {
                            delete CONCURRENT_PROMISES[key];
                            delete CONCURRENT_PROMISES_TS[key];
                        }, config.dedupingInterval);
                        // trigger the success event,
                        // only do this for the original request.
                        eventsCallback('onSuccess', newData, key, config);
                        _c.label = 5;
                    case 5:
                        // if there're other ongoing request(s), started after the current one,
                        // we need to ignore the current one to avoid possible race conditions:
                        //   req1------------------>res1        (current one)
                        //        req2---------------->res2
                        // the request that fired later will always be kept.
                        if (CONCURRENT_PROMISES_TS[key] > startAt) {
                            return [2 /*return*/, false];
                        }
                        // if there're other mutations(s), overlapped with the current revalidation:
                        // case 1:
                        //   req------------------>res
                        //       mutate------>end
                        // case 2:
                        //         req------------>res
                        //   mutate------>end
                        // case 3:
                        //   req------------------>res
                        //       mutate-------...---------->
                        // we have to ignore the revalidation result (res) because it's no longer fresh.
                        // meanwhile, a new revalidation should be triggered when the mutation ends.
                        if (MUTATION_TS[key] &&
                            // case 1
                            (startAt <= MUTATION_TS[key] ||
                                // case 2
                                startAt <= MUTATION_END_TS[key] ||
                                // case 3
                                MUTATION_END_TS[key] === 0)) {
                            dispatch({ isValidating: false });
                            return [2 /*return*/, false];
                        }
                        _config__WEBPACK_IMPORTED_MODULE_1__["cache"].set(keyErr, undefined);
                        _config__WEBPACK_IMPORTED_MODULE_1__["cache"].set(keyValidating, false);
                        newState = {
                            isValidating: false
                        };
                        if (typeof stateRef.current.error !== 'undefined') {
                            // we don't have an error
                            newState.error = undefined;
                        }
                        if (!config.compare(stateRef.current.data, newData)) {
                            // deep compare to avoid extra re-render
                            // data changed
                            newState.data = newData;
                        }
                        if (!config.compare(_config__WEBPACK_IMPORTED_MODULE_1__["cache"].get(key), newData)) {
                            _config__WEBPACK_IMPORTED_MODULE_1__["cache"].set(key, newData);
                        }
                        // merge the new state
                        dispatch(newState);
                        if (!shouldDeduping) {
                            // also update other hooks
                            broadcastState(key, newData, newState.error, false);
                        }
                        return [3 /*break*/, 7];
                    case 6:
                        err_2 = _c.sent();
                        delete CONCURRENT_PROMISES[key];
                        delete CONCURRENT_PROMISES_TS[key];
                        if (configRef.current.isPaused()) {
                            dispatch({
                                isValidating: false
                            });
                            return [2 /*return*/, false];
                        }
                        _config__WEBPACK_IMPORTED_MODULE_1__["cache"].set(keyErr, err_2);
                        // get a new error
                        // don't use deep equal for errors
                        if (stateRef.current.error !== err_2) {
                            // we keep the stale data
                            dispatch({
                                isValidating: false,
                                error: err_2
                            });
                            if (!shouldDeduping) {
                                // also broadcast to update other hooks
                                broadcastState(key, undefined, err_2, false);
                            }
                        }
                        // events and retry
                        eventsCallback('onError', err_2, key, config);
                        if (config.shouldRetryOnError) {
                            // when retrying, we always enable deduping
                            eventsCallback('onErrorRetry', err_2, key, config, revalidate, {
                                retryCount: retryCount + 1,
                                dedupe: true
                            });
                        }
                        return [3 /*break*/, 7];
                    case 7:
                        loading = false;
                        return [2 /*return*/, true];
                }
            });
        });
    }, 
    // dispatch is immutable, and `eventsCallback`, `fnArgs`, `keyErr`, and `keyValidating` are based on `key`,
    // so we can them from the deps array.
    //
    // FIXME:
    // `fn` and `config` might be changed during the lifecycle,
    // but they might be changed every render like this.
    // useSWR('key', () => fetch('/api/'), { suspense: true })
    // So we omit the values from the deps array
    // even though it might cause unexpected behaviors.
    // eslint-disable-next-line react-hooks/exhaustive-deps
    [key]);
    // mounted (client side rendering)
    Object(_env__WEBPACK_IMPORTED_MODULE_2__["useIsomorphicLayoutEffect"])(function () {
        if (!key)
            return undefined;
        // after `key` updates, we need to mark it as mounted
        unmountedRef.current = false;
        var isUpdating = initialMountedRef.current;
        initialMountedRef.current = true;
        // after the component is mounted (hydrated),
        // we need to update the data from the cache
        // and trigger a revalidation
        var currentHookData = stateRef.current.data;
        var latestKeyedData = resolveData();
        // update the state if the key changed (not the inital render) or cache updated
        keyRef.current = key;
        if (!config.compare(currentHookData, latestKeyedData)) {
            dispatch({ data: latestKeyedData });
        }
        // revalidate with deduping
        var softRevalidate = function () { return revalidate({ dedupe: true }); };
        // trigger a revalidation
        if (isUpdating || willRevalidateOnMount()) {
            if (typeof latestKeyedData !== 'undefined' && !_env__WEBPACK_IMPORTED_MODULE_2__["IS_SERVER"]) {
                // delay revalidate if there's cache
                // to not block the rendering
                // @ts-ignore it's safe to use requestAnimationFrame in browser
                Object(_env__WEBPACK_IMPORTED_MODULE_2__["rAF"])(softRevalidate);
            }
            else {
                softRevalidate();
            }
        }
        var pending = false;
        var onFocus = function () {
            if (pending || !configRef.current.revalidateOnFocus)
                return;
            pending = true;
            softRevalidate();
            setTimeout(function () { return (pending = false); }, configRef.current.focusThrottleInterval);
        };
        var onReconnect = function () {
            if (configRef.current.revalidateOnReconnect) {
                softRevalidate();
            }
        };
        // register global cache update listener
        var onUpdate = function (shouldRevalidate, updatedData, updatedError, updatedIsValidating, dedupe) {
            if (shouldRevalidate === void 0) { shouldRevalidate = true; }
            if (dedupe === void 0) { dedupe = true; }
            // update hook state
            var newState = {};
            var needUpdate = false;
            if (typeof updatedData !== 'undefined' &&
                !config.compare(stateRef.current.data, updatedData)) {
                newState.data = updatedData;
                needUpdate = true;
            }
            // always update error
            // because it can be `undefined`
            if (stateRef.current.error !== updatedError) {
                newState.error = updatedError;
                needUpdate = true;
            }
            if (typeof updatedIsValidating !== 'undefined' &&
                stateRef.current.isValidating !== updatedIsValidating) {
                newState.isValidating = updatedIsValidating;
                needUpdate = true;
            }
            if (needUpdate) {
                dispatch(newState);
            }
            if (shouldRevalidate) {
                if (dedupe) {
                    return softRevalidate();
                }
                else {
                    return revalidate();
                }
            }
            return false;
        };
        var unsubFocus = addRevalidator(FOCUS_REVALIDATORS, onFocus);
        var unsubReconnect = addRevalidator(RECONNECT_REVALIDATORS, onReconnect);
        var unsubUpdate = addRevalidator(CACHE_REVALIDATORS, onUpdate);
        return function () {
            // cleanup
            dispatch = function () { return null; };
            // mark it as unmounted
            unmountedRef.current = true;
            unsubFocus();
            unsubReconnect();
            unsubUpdate();
        };
    }, [key, revalidate]);
    Object(_env__WEBPACK_IMPORTED_MODULE_2__["useIsomorphicLayoutEffect"])(function () {
        var timer = null;
        var tick = function () { return __awaiter(_this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        if (!(!stateRef.current.error &&
                            (configRef.current.refreshWhenHidden ||
                                configRef.current.isDocumentVisible()) &&
                            (configRef.current.refreshWhenOffline || configRef.current.isOnline()))) return [3 /*break*/, 2];
                        // only revalidate when the page is visible
                        // if API request errored, we stop polling in this round
                        // and let the error retry function handle it
                        return [4 /*yield*/, revalidate({ dedupe: true })];
                    case 1:
                        // only revalidate when the page is visible
                        // if API request errored, we stop polling in this round
                        // and let the error retry function handle it
                        _a.sent();
                        _a.label = 2;
                    case 2:
                        // Read the latest refreshInterval
                        if (configRef.current.refreshInterval && timer) {
                            timer = setTimeout(tick, configRef.current.refreshInterval);
                        }
                        return [2 /*return*/];
                }
            });
        }); };
        if (configRef.current.refreshInterval) {
            timer = setTimeout(tick, configRef.current.refreshInterval);
        }
        return function () {
            if (timer) {
                clearTimeout(timer);
                timer = null;
            }
        };
    }, [
        config.refreshInterval,
        config.refreshWhenHidden,
        config.refreshWhenOffline,
        revalidate
    ]);
    // suspense
    var latestData;
    var latestError;
    if (config.suspense) {
        // in suspense mode, we can't return empty state
        // (it should be suspended)
        // try to get data and error from cache
        latestData = _config__WEBPACK_IMPORTED_MODULE_1__["cache"].get(key);
        latestError = _config__WEBPACK_IMPORTED_MODULE_1__["cache"].get(keyErr);
        if (typeof latestData === 'undefined') {
            latestData = initialData;
        }
        if (typeof latestError === 'undefined') {
            latestError = initialError;
        }
        if (typeof latestData === 'undefined' &&
            typeof latestError === 'undefined') {
            // need to start the request if it hasn't
            if (!CONCURRENT_PROMISES[key]) {
                // trigger revalidate immediately
                // to get the promise
                // in this revalidate, should not rerender
                revalidate();
            }
            if (CONCURRENT_PROMISES[key] &&
                typeof CONCURRENT_PROMISES[key].then === 'function') {
                // if it is a promise
                throw CONCURRENT_PROMISES[key];
            }
            // it's a value, return it directly (override)
            latestData = CONCURRENT_PROMISES[key];
        }
        if (typeof latestData === 'undefined' && latestError) {
            // in suspense mode, throw error if there's no content
            throw latestError;
        }
    }
    // define returned state
    // can be memorized since the state is a ref
    var memoizedState = Object(react__WEBPACK_IMPORTED_MODULE_0__["useMemo"])(function () {
        // revalidate will be deprecated in the 1.x release
        // because mutate() covers the same use case of revalidate().
        // This remains only for backward compatibility
        var state = { revalidate: revalidate, mutate: boundMutate };
        Object.defineProperties(state, {
            error: {
                // `key` might be changed in the upcoming hook re-render,
                // but the previous state will stay
                // so we need to match the latest key and data (fallback to `initialData`)
                get: function () {
                    stateDependencies.current.error = true;
                    if (config.suspense) {
                        return latestError;
                    }
                    return keyRef.current === key ? stateRef.current.error : initialError;
                },
                enumerable: true
            },
            data: {
                get: function () {
                    stateDependencies.current.data = true;
                    if (config.suspense) {
                        return latestData;
                    }
                    return keyRef.current === key ? stateRef.current.data : initialData;
                },
                enumerable: true
            },
            isValidating: {
                get: function () {
                    stateDependencies.current.isValidating = true;
                    return key ? stateRef.current.isValidating : false;
                },
                enumerable: true
            }
        });
        return state;
        // `config.suspense` isn't allowed to change during the lifecycle.
        // `boundMutate` is immutable, and the immutability of `revalidate` depends on `key`
        // so we can omit them from the deps array,
        // but we put it to enable react-hooks/exhaustive-deps rule.
        // `initialData` and `initialError` are not initial values
        // because they are changed during the lifecycle
        // so we should add them in the deps array.
    }, [
        revalidate,
        initialData,
        initialError,
        boundMutate,
        key,
        config.suspense,
        latestError,
        latestData
    ]);
    return memoizedState;
}
Object.defineProperty(_swr_config_context__WEBPACK_IMPORTED_MODULE_3__["default"].Provider, 'default', {
    value: _config__WEBPACK_IMPORTED_MODULE_1__["default"]
});
var SWRConfig = _swr_config_context__WEBPACK_IMPORTED_MODULE_3__["default"].Provider;

/* harmony default export */ __webpack_exports__["default"] = (useSWR);


/***/ }),

/***/ "./pages/events/[...slug].js":
/*!***********************************!*\
  !*** ./pages/events/[...slug].js ***!
  \***********************************/
/*! exports provided: __N_SSP, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* WEBPACK VAR INJECTION */(function(module) {/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__N_SSP", function() { return __N_SSP; });
/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ "./node_modules/react/jsx-dev-runtime.js");
/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ "./node_modules/react/index.js");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var next_router__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! next/router */ "./node_modules/next/router.js");
/* harmony import */ var next_router__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(next_router__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var swr__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! swr */ "./node_modules/swr/esm/index.js");
/* harmony import */ var _components_events_event_list__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../components/events/event-list */ "./components/events/event-list.js");
/* harmony import */ var _components_results_title_results_title__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../components/results-title/results-title */ "./components/results-title/results-title.js");
/* harmony import */ var _components_ui_button__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../../components/ui/button */ "./components/ui/button.js");
/* harmony import */ var _components_error_alert_error_alert__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../../components/error-alert/error-alert */ "./components/error-alert/error-alert.js");


var _jsxFileName = "C:\\Users\\vuong\\OneDrive\\M\xE1y t\xEDnh\\Courses\\NextJS-Course\\pages\\events\\[...slug].js",
    _s = $RefreshSig$();









function FilteredEventsPage(props) {
  _s();

  var router = Object(next_router__WEBPACK_IMPORTED_MODULE_2__["useRouter"])();
  var filterData = router.query.slug;

  if (!filterData) {
    return /*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__["jsxDEV"])("p", {
      className: "center",
      children: "Loading..."
    }, void 0, false, {
      fileName: _jsxFileName,
      lineNumber: 17,
      columnNumber: 12
    }, this);
  }

  var filteredYear = filterData[0];
  var filteredMonth = filterData[1];
  var numYear = +filteredYear;
  var numMonth = +filteredMonth;

  if (props.hasError) {
    return /*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__["jsxDEV"])(react__WEBPACK_IMPORTED_MODULE_1__["Fragment"], {
      children: [/*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__["jsxDEV"])(_components_error_alert_error_alert__WEBPACK_IMPORTED_MODULE_7__["default"], {
        children: "Invalid filter. ErrorAlertlease adjust your values!"
      }, void 0, false, {
        fileName: _jsxFileName,
        lineNumber: 29,
        columnNumber: 9
      }, this), /*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__["jsxDEV"])("div", {
        className: "center",
        children: /*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__["jsxDEV"])(_components_ui_button__WEBPACK_IMPORTED_MODULE_6__["default"], {
          link: "/events",
          children: "Show All Events"
        }, void 0, false, {
          fileName: _jsxFileName,
          lineNumber: 33,
          columnNumber: 11
        }, this)
      }, void 0, false, {
        fileName: _jsxFileName,
        lineNumber: 32,
        columnNumber: 9
      }, this)]
    }, void 0, true, {
      fileName: _jsxFileName,
      lineNumber: 28,
      columnNumber: 7
    }, this);
  }

  var filteredEvents = props.events;

  if (!filteredEvents || filteredEvents.length === 0) {
    return /*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__["jsxDEV"])(react__WEBPACK_IMPORTED_MODULE_1__["Fragment"], {
      children: /*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__["jsxDEV"])(_components_error_alert_error_alert__WEBPACK_IMPORTED_MODULE_7__["default"], {
        children: "No events found for the chosen filter!"
      }, void 0, false, {
        fileName: _jsxFileName,
        lineNumber: 44,
        columnNumber: 9
      }, this)
    }, void 0, false, {
      fileName: _jsxFileName,
      lineNumber: 43,
      columnNumber: 7
    }, this);
  }

  var date = new Date(props.date.year, props.date.month - 1);
  return /*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__["jsxDEV"])(react__WEBPACK_IMPORTED_MODULE_1__["Fragment"], {
    children: [/*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__["jsxDEV"])(_components_results_title_results_title__WEBPACK_IMPORTED_MODULE_5__["default"], {
      date: date
    }, void 0, false, {
      fileName: _jsxFileName,
      lineNumber: 53,
      columnNumber: 7
    }, this), /*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__["jsxDEV"])(_components_events_event_list__WEBPACK_IMPORTED_MODULE_4__["default"], {
      items: filteredEvents
    }, void 0, false, {
      fileName: _jsxFileName,
      lineNumber: 54,
      columnNumber: 7
    }, this)]
  }, void 0, true, {
    fileName: _jsxFileName,
    lineNumber: 52,
    columnNumber: 5
  }, this);
}

_s(FilteredEventsPage, "fN7XvhJ+p5oE6+Xlo0NJmXpxjC8=", false, function () {
  return [next_router__WEBPACK_IMPORTED_MODULE_2__["useRouter"]];
});

_c = FilteredEventsPage;
var __N_SSP = true;
/* harmony default export */ __webpack_exports__["default"] = (FilteredEventsPage);

var _c;

$RefreshReg$(_c, "FilteredEventsPage");

;
    var _a, _b;
    // Legacy CSS implementations will `eval` browser code in a Node.js context
    // to extract CSS. For backwards compatibility, we need to check we're in a
    // browser context before continuing.
    if (typeof self !== 'undefined' &&
        // AMP / No-JS mode does not inject these helpers:
        '$RefreshHelpers$' in self) {
        var currentExports = module.__proto__.exports;
        var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;
        // This cannot happen in MainTemplate because the exports mismatch between
        // templating and execution.
        self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.i);
        // A module can be accepted automatically based on its exports, e.g. when
        // it is a Refresh Boundary.
        if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {
            // Save the previous exports on update so we can compare the boundary
            // signatures.
            module.hot.dispose(function (data) {
                data.prevExports = currentExports;
            });
            // Unconditionally accept an update to this module, we'll check if it's
            // still a Refresh Boundary later.
            module.hot.accept();
            // This field is set when the previous version of this module was a
            // Refresh Boundary, letting us know we need to check for invalidation or
            // enqueue an update.
            if (prevExports !== null) {
                // A boundary can become ineligible if its exports are incompatible
                // with the previous exports.
                //
                // For example, if you add/remove/change exports, we'll want to
                // re-execute the importing modules, and force those components to
                // re-render. Similarly, if you convert a class component to a
                // function, we want to invalidate the boundary.
                if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {
                    module.hot.invalidate();
                }
                else {
                    self.$RefreshHelpers$.scheduleUpdate();
                }
            }
        }
        else {
            // Since we just executed the code for the module, it's possible that the
            // new exports made it ineligible for being a boundary.
            // We only care about the case when we were _previously_ a boundary,
            // because we already accepted this update (accidental side effect).
            var isNoLongerABoundary = prevExports !== null;
            if (isNoLongerABoundary) {
                module.hot.invalidate();
            }
        }
    }

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../node_modules/next/dist/compiled/webpack/harmony-module.js */ "./node_modules/next/dist/compiled/webpack/harmony-module.js")(module)))

/***/ })

})
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL2RlcXVhbC9saXRlL2luZGV4Lm1qcyIsIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL3N3ci9lc20vY2FjaGUuanMiLCJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9zd3IvZXNtL2NvbmZpZy5qcyIsIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL3N3ci9lc20vZW52LmpzIiwid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvc3dyL2VzbS9pbmRleC5qcyIsIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL3N3ci9lc20vbGlicy9oYXNoLmpzIiwid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvc3dyL2VzbS9saWJzL3dlYi1wcmVzZXQuanMiLCJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9zd3IvZXNtL3N3ci1jb25maWctY29udGV4dC5qcyIsIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL3N3ci9lc20vdXNlLXN3ci1pbmZpbml0ZS5qcyIsIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL3N3ci9lc20vdXNlLXN3ci5qcyIsIndlYnBhY2s6Ly9fTl9FLy4vcGFnZXMvZXZlbnRzL1suLi5zbHVnXS5qcyJdLCJuYW1lcyI6WyJGaWx0ZXJlZEV2ZW50c1BhZ2UiLCJwcm9wcyIsInJvdXRlciIsInVzZVJvdXRlciIsImZpbHRlckRhdGEiLCJxdWVyeSIsInNsdWciLCJmaWx0ZXJlZFllYXIiLCJmaWx0ZXJlZE1vbnRoIiwibnVtWWVhciIsIm51bU1vbnRoIiwiaGFzRXJyb3IiLCJmaWx0ZXJlZEV2ZW50cyIsImV2ZW50cyIsImxlbmd0aCIsImRhdGUiLCJEYXRlIiwieWVhciIsIm1vbnRoIl0sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7O0FBQUE7QUFBQTtBQUFBOztBQUVPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtB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QUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQURGO0FBQUE7QUFBQTtBQUFBO0FBQUEsWUFERjtBQUtEOztBQUVELE1BQU1DLElBQUksR0FBRyxJQUFJQyxJQUFKLENBQVNmLEtBQUssQ0FBQ2MsSUFBTixDQUFXRSxJQUFwQixFQUEwQmhCLEtBQUssQ0FBQ2MsSUFBTixDQUFXRyxLQUFYLEdBQW1CLENBQTdDLENBQWI7QUFFQSxzQkFDRSxxRUFBQyw4Q0FBRDtBQUFBLDRCQUNFLHFFQUFDLCtFQUFEO0FBQWMsVUFBSSxFQUFFSDtBQUFwQjtBQUFBO0FBQUE7QUFBQTtBQUFBLFlBREYsZUFFRSxxRUFBQyxxRUFBRDtBQUFXLFdBQUssRUFBRUg7QUFBbEI7QUFBQTtBQUFBO0FBQUE7QUFBQSxZQUZGO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxVQURGO0FBTUQ7O0dBOUNRWixrQjtVQUNRRyxxRDs7O0tBRFJILGtCOztBQXVGTUEsaUZBQWYiLCJmaWxlIjoic3RhdGljL3dlYnBhY2svcGFnZXMvZXZlbnRzL1suLi5zbHVnXS41MGJkMmM5ZjU3YWJlZWU4NjBlNS5ob3QtdXBkYXRlLmpzIiwic291cmNlc0NvbnRlbnQiOlsidmFyIGhhcyA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG5cbmV4cG9ydCBmdW5jdGlvbiBkZXF1YWwoZm9vLCBiYXIpIHtcblx0dmFyIGN0b3IsIGxlbjtcblx0aWYgKGZvbyA9PT0gYmFyKSByZXR1cm4gdHJ1ZTtcblxuXHRpZiAoZm9vICYmIGJhciAmJiAoY3Rvcj1mb28uY29uc3RydWN0b3IpID09PSBiYXIuY29uc3RydWN0b3IpIHtcblx0XHRpZiAoY3RvciA9PT0gRGF0ZSkgcmV0dXJuIGZvby5nZXRUaW1lKCkgPT09IGJhci5nZXRUaW1lKCk7XG5cdFx0aWYgKGN0b3IgPT09IFJlZ0V4cCkgcmV0dXJuIGZvby50b1N0cmluZygpID09PSBiYXIudG9TdHJpbmcoKTtcblxuXHRcdGlmIChjdG9yID09PSBBcnJheSkge1xuXHRcdFx0aWYgKChsZW49Zm9vLmxlbmd0aCkgPT09IGJhci5sZW5ndGgpIHtcblx0XHRcdFx0d2hpbGUgKGxlbi0tICYmIGRlcXVhbChmb29bbGVuXSwgYmFyW2xlbl0pKTtcblx0XHRcdH1cblx0XHRcdHJldHVybiBsZW4gPT09IC0xO1xuXHRcdH1cblxuXHRcdGlmICghY3RvciB8fCB0eXBlb2YgZm9vID09PSAnb2JqZWN0Jykge1xuXHRcdFx0bGVuID0gMDtcblx0XHRcdGZvciAoY3RvciBpbiBmb28pIHtcblx0XHRcdFx0aWYgKGhhcy5jYWxsKGZvbywgY3RvcikgJiYgKytsZW4gJiYgIWhhcy5jYWxsKGJhciwgY3RvcikpIHJldHVybiBmYWxzZTtcblx0XHRcdFx0aWYgKCEoY3RvciBpbiBiYXIpIHx8ICFkZXF1YWwoZm9vW2N0b3JdLCBiYXJbY3Rvcl0pKSByZXR1cm4gZmFsc2U7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gT2JqZWN0LmtleXMoYmFyKS5sZW5ndGggPT09IGxlbjtcblx0XHR9XG5cdH1cblxuXHRyZXR1cm4gZm9vICE9PSBmb28gJiYgYmFyICE9PSBiYXI7XG59XG4iLCJpbXBvcnQgaGFzaCBmcm9tICcuL2xpYnMvaGFzaCc7XG52YXIgQ2FjaGUgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gQ2FjaGUoaW5pdGlhbERhdGEpIHtcbiAgICAgICAgaWYgKGluaXRpYWxEYXRhID09PSB2b2lkIDApIHsgaW5pdGlhbERhdGEgPSB7fTsgfVxuICAgICAgICB0aGlzLmNhY2hlID0gbmV3IE1hcChPYmplY3QuZW50cmllcyhpbml0aWFsRGF0YSkpO1xuICAgICAgICB0aGlzLnN1YnMgPSBbXTtcbiAgICB9XG4gICAgQ2FjaGUucHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgdmFyIF9rZXkgPSB0aGlzLnNlcmlhbGl6ZUtleShrZXkpWzBdO1xuICAgICAgICByZXR1cm4gdGhpcy5jYWNoZS5nZXQoX2tleSk7XG4gICAgfTtcbiAgICBDYWNoZS5wcm90b3R5cGUuc2V0ID0gZnVuY3Rpb24gKGtleSwgdmFsdWUpIHtcbiAgICAgICAgdmFyIF9rZXkgPSB0aGlzLnNlcmlhbGl6ZUtleShrZXkpWzBdO1xuICAgICAgICB0aGlzLmNhY2hlLnNldChfa2V5LCB2YWx1ZSk7XG4gICAgICAgIHRoaXMubm90aWZ5KCk7XG4gICAgfTtcbiAgICBDYWNoZS5wcm90b3R5cGUua2V5cyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIEFycmF5LmZyb20odGhpcy5jYWNoZS5rZXlzKCkpO1xuICAgIH07XG4gICAgQ2FjaGUucHJvdG90eXBlLmhhcyA9IGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgdmFyIF9rZXkgPSB0aGlzLnNlcmlhbGl6ZUtleShrZXkpWzBdO1xuICAgICAgICByZXR1cm4gdGhpcy5jYWNoZS5oYXMoX2tleSk7XG4gICAgfTtcbiAgICBDYWNoZS5wcm90b3R5cGUuY2xlYXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuY2FjaGUuY2xlYXIoKTtcbiAgICAgICAgdGhpcy5ub3RpZnkoKTtcbiAgICB9O1xuICAgIENhY2hlLnByb3RvdHlwZS5kZWxldGUgPSBmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgIHZhciBfa2V5ID0gdGhpcy5zZXJpYWxpemVLZXkoa2V5KVswXTtcbiAgICAgICAgdGhpcy5jYWNoZS5kZWxldGUoX2tleSk7XG4gICAgICAgIHRoaXMubm90aWZ5KCk7XG4gICAgfTtcbiAgICAvLyBUT0RPOiBpbnRyb2R1Y2UgbmFtZXNwYWNlIGZvciB0aGUgY2FjaGVcbiAgICBDYWNoZS5wcm90b3R5cGUuc2VyaWFsaXplS2V5ID0gZnVuY3Rpb24gKGtleSkge1xuICAgICAgICB2YXIgYXJncyA9IG51bGw7XG4gICAgICAgIGlmICh0eXBlb2Yga2V5ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGtleSA9IGtleSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgICAgIC8vIGRlcGVuZGVuY2llcyBub3QgcmVhZHlcbiAgICAgICAgICAgICAgICBrZXkgPSAnJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShrZXkpKSB7XG4gICAgICAgICAgICAvLyBhcmdzIGFycmF5XG4gICAgICAgICAgICBhcmdzID0ga2V5O1xuICAgICAgICAgICAga2V5ID0gaGFzaChrZXkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLy8gY29udmVydCBudWxsIHRvICcnXG4gICAgICAgICAgICBrZXkgPSBTdHJpbmcoa2V5IHx8ICcnKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgZXJyb3JLZXkgPSBrZXkgPyAnZXJyQCcgKyBrZXkgOiAnJztcbiAgICAgICAgdmFyIGlzVmFsaWRhdGluZ0tleSA9IGtleSA/ICd2YWxpZGF0aW5nQCcgKyBrZXkgOiAnJztcbiAgICAgICAgcmV0dXJuIFtrZXksIGFyZ3MsIGVycm9yS2V5LCBpc1ZhbGlkYXRpbmdLZXldO1xuICAgIH07XG4gICAgQ2FjaGUucHJvdG90eXBlLnN1YnNjcmliZSA9IGZ1bmN0aW9uIChsaXN0ZW5lcikge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICBpZiAodHlwZW9mIGxpc3RlbmVyICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0V4cGVjdGVkIHRoZSBsaXN0ZW5lciB0byBiZSBhIGZ1bmN0aW9uLicpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBpc1N1YnNjcmliZWQgPSB0cnVlO1xuICAgICAgICB0aGlzLnN1YnMucHVzaChsaXN0ZW5lcik7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAoIWlzU3Vic2NyaWJlZClcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICBpc1N1YnNjcmliZWQgPSBmYWxzZTtcbiAgICAgICAgICAgIHZhciBpbmRleCA9IF90aGlzLnN1YnMuaW5kZXhPZihsaXN0ZW5lcik7XG4gICAgICAgICAgICBpZiAoaW5kZXggPiAtMSkge1xuICAgICAgICAgICAgICAgIF90aGlzLnN1YnNbaW5kZXhdID0gX3RoaXMuc3Vic1tfdGhpcy5zdWJzLmxlbmd0aCAtIDFdO1xuICAgICAgICAgICAgICAgIF90aGlzLnN1YnMubGVuZ3RoLS07XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgfTtcbiAgICAvLyBOb3RpZnkgQ2FjaGUgc3Vic2NyaWJlcnMgYWJvdXQgYSBjaGFuZ2UgaW4gdGhlIGNhY2hlXG4gICAgQ2FjaGUucHJvdG90eXBlLm5vdGlmeSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZm9yICh2YXIgX2kgPSAwLCBfYSA9IHRoaXMuc3ViczsgX2kgPCBfYS5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgIHZhciBsaXN0ZW5lciA9IF9hW19pXTtcbiAgICAgICAgICAgIGxpc3RlbmVyKCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHJldHVybiBDYWNoZTtcbn0oKSk7XG5leHBvcnQgZGVmYXVsdCBDYWNoZTtcbiIsInZhciBfX2Fzc2lnbiA9ICh0aGlzICYmIHRoaXMuX19hc3NpZ24pIHx8IGZ1bmN0aW9uICgpIHtcbiAgICBfX2Fzc2lnbiA9IE9iamVjdC5hc3NpZ24gfHwgZnVuY3Rpb24odCkge1xuICAgICAgICBmb3IgKHZhciBzLCBpID0gMSwgbiA9IGFyZ3VtZW50cy5sZW5ndGg7IGkgPCBuOyBpKyspIHtcbiAgICAgICAgICAgIHMgPSBhcmd1bWVudHNbaV07XG4gICAgICAgICAgICBmb3IgKHZhciBwIGluIHMpIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwocywgcCkpXG4gICAgICAgICAgICAgICAgdFtwXSA9IHNbcF07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHQ7XG4gICAgfTtcbiAgICByZXR1cm4gX19hc3NpZ24uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn07XG5pbXBvcnQgeyBkZXF1YWwgfSBmcm9tICdkZXF1YWwvbGl0ZSc7XG5pbXBvcnQgQ2FjaGUgZnJvbSAnLi9jYWNoZSc7XG5pbXBvcnQgd2ViUHJlc2V0IGZyb20gJy4vbGlicy93ZWItcHJlc2V0Jztcbi8vIGNhY2hlXG52YXIgY2FjaGUgPSBuZXcgQ2FjaGUoKTtcbi8vIGVycm9yIHJldHJ5XG5mdW5jdGlvbiBvbkVycm9yUmV0cnkoXywgX18sIGNvbmZpZywgcmV2YWxpZGF0ZSwgb3B0cykge1xuICAgIGlmICghY29uZmlnLmlzRG9jdW1lbnRWaXNpYmxlKCkpIHtcbiAgICAgICAgLy8gaWYgaXQncyBoaWRkZW4sIHN0b3BcbiAgICAgICAgLy8gaXQgd2lsbCBhdXRvIHJldmFsaWRhdGUgd2hlbiBmb2N1c1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICh0eXBlb2YgY29uZmlnLmVycm9yUmV0cnlDb3VudCA9PT0gJ251bWJlcicgJiZcbiAgICAgICAgb3B0cy5yZXRyeUNvdW50ID4gY29uZmlnLmVycm9yUmV0cnlDb3VudCkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIC8vIGV4cG9uZW50aWFsIGJhY2tvZmZcbiAgICB2YXIgY291bnQgPSBNYXRoLm1pbihvcHRzLnJldHJ5Q291bnQsIDgpO1xuICAgIHZhciB0aW1lb3V0ID0gfn4oKE1hdGgucmFuZG9tKCkgKyAwLjUpICogKDEgPDwgY291bnQpKSAqIGNvbmZpZy5lcnJvclJldHJ5SW50ZXJ2YWw7XG4gICAgc2V0VGltZW91dChyZXZhbGlkYXRlLCB0aW1lb3V0LCBvcHRzKTtcbn1cbi8vIGNsaWVudCBzaWRlOiBuZWVkIHRvIGFkanVzdCB0aGUgY29uZmlnXG4vLyBiYXNlZCBvbiB0aGUgYnJvd3NlciBzdGF0dXNcbi8vIHNsb3cgY29ubmVjdGlvbiAoPD0gNzBLYnBzKVxudmFyIHNsb3dDb25uZWN0aW9uID0gdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiZcbiAgICAvLyBAdHMtaWdub3JlXG4gICAgbmF2aWdhdG9yWydjb25uZWN0aW9uJ10gJiZcbiAgICAvLyBAdHMtaWdub3JlXG4gICAgWydzbG93LTJnJywgJzJnJ10uaW5kZXhPZihuYXZpZ2F0b3JbJ2Nvbm5lY3Rpb24nXS5lZmZlY3RpdmVUeXBlKSAhPT0gLTE7XG4vLyBjb25maWdcbnZhciBkZWZhdWx0Q29uZmlnID0gX19hc3NpZ24oeyBcbiAgICAvLyBldmVudHNcbiAgICBvbkxvYWRpbmdTbG93OiBmdW5jdGlvbiAoKSB7IH0sIG9uU3VjY2VzczogZnVuY3Rpb24gKCkgeyB9LCBvbkVycm9yOiBmdW5jdGlvbiAoKSB7IH0sIG9uRXJyb3JSZXRyeTogb25FcnJvclJldHJ5LCBlcnJvclJldHJ5SW50ZXJ2YWw6IChzbG93Q29ubmVjdGlvbiA/IDEwIDogNSkgKiAxMDAwLCBmb2N1c1Rocm90dGxlSW50ZXJ2YWw6IDUgKiAxMDAwLCBkZWR1cGluZ0ludGVydmFsOiAyICogMTAwMCwgbG9hZGluZ1RpbWVvdXQ6IChzbG93Q29ubmVjdGlvbiA/IDUgOiAzKSAqIDEwMDAsIHJlZnJlc2hJbnRlcnZhbDogMCwgcmV2YWxpZGF0ZU9uRm9jdXM6IHRydWUsIHJldmFsaWRhdGVPblJlY29ubmVjdDogdHJ1ZSwgcmVmcmVzaFdoZW5IaWRkZW46IGZhbHNlLCByZWZyZXNoV2hlbk9mZmxpbmU6IGZhbHNlLCBzaG91bGRSZXRyeU9uRXJyb3I6IHRydWUsIHN1c3BlbnNlOiBmYWxzZSwgY29tcGFyZTogZGVxdWFsLCBpc1BhdXNlZDogZnVuY3Rpb24gKCkgeyByZXR1cm4gZmFsc2U7IH0gfSwgd2ViUHJlc2V0KTtcbmV4cG9ydCB7IGNhY2hlIH07XG5leHBvcnQgZGVmYXVsdCBkZWZhdWx0Q29uZmlnO1xuIiwiaW1wb3J0IHsgdXNlRWZmZWN0LCB1c2VMYXlvdXRFZmZlY3QgfSBmcm9tICdyZWFjdCc7XG5leHBvcnQgdmFyIElTX1NFUlZFUiA9IHR5cGVvZiB3aW5kb3cgPT09ICd1bmRlZmluZWQnIHx8XG4gICAgLy8gQHRzLWlnbm9yZVxuICAgICEhKHR5cGVvZiBEZW5vICE9PSAndW5kZWZpbmVkJyAmJiBEZW5vICYmIERlbm8udmVyc2lvbiAmJiBEZW5vLnZlcnNpb24uZGVubyk7XG4vLyBwb2x5ZmlsbCBmb3IgcmVxdWVzdEFuaW1hdGlvbkZyYW1lXG5leHBvcnQgdmFyIHJBRiA9IElTX1NFUlZFUlxuICAgID8gbnVsbFxuICAgIDogd2luZG93WydyZXF1ZXN0QW5pbWF0aW9uRnJhbWUnXVxuICAgICAgICA/IGZ1bmN0aW9uIChmKSB7IHJldHVybiB3aW5kb3dbJ3JlcXVlc3RBbmltYXRpb25GcmFtZSddKGYpOyB9XG4gICAgICAgIDogZnVuY3Rpb24gKGYpIHsgcmV0dXJuIHNldFRpbWVvdXQoZiwgMSk7IH07XG4vLyBSZWFjdCBjdXJyZW50bHkgdGhyb3dzIGEgd2FybmluZyB3aGVuIHVzaW5nIHVzZUxheW91dEVmZmVjdCBvbiB0aGUgc2VydmVyLlxuLy8gVG8gZ2V0IGFyb3VuZCBpdCwgd2UgY2FuIGNvbmRpdGlvbmFsbHkgdXNlRWZmZWN0IG9uIHRoZSBzZXJ2ZXIgKG5vLW9wKSBhbmRcbi8vIHVzZUxheW91dEVmZmVjdCBpbiB0aGUgYnJvd3Nlci5cbmV4cG9ydCB2YXIgdXNlSXNvbW9ycGhpY0xheW91dEVmZmVjdCA9IElTX1NFUlZFUiA/IHVzZUVmZmVjdCA6IHVzZUxheW91dEVmZmVjdDtcbiIsIi8vIGB1c2VTV1JgIGFuZCByZWxhdGVkIEFQSXNcbmltcG9ydCB7IGRlZmF1bHQgYXMgdXNlU1dSIH0gZnJvbSAnLi91c2Utc3dyJztcbmV4cG9ydCBkZWZhdWx0IHVzZVNXUjtcbmV4cG9ydCAqIGZyb20gJy4vdXNlLXN3cic7XG4vLyBgdXNlU1dSSW5maW5pdGVgXG5leHBvcnQgeyB1c2VTV1JJbmZpbml0ZSB9IGZyb20gJy4vdXNlLXN3ci1pbmZpbml0ZSc7XG4vLyBDYWNoZSByZWxhdGVkLCB0byBiZSByZXBsYWNlZCBieSB0aGUgbmV3IEFQSXNcbmV4cG9ydCB7IGNhY2hlIH0gZnJvbSAnLi9jb25maWcnO1xuIiwiLy8gdXNlIFdlYWtNYXAgdG8gc3RvcmUgdGhlIG9iamVjdC0+a2V5IG1hcHBpbmdcbi8vIHNvIHRoZSBvYmplY3RzIGNhbiBiZSBnYXJiYWdlIGNvbGxlY3RlZC5cbi8vIFdlYWtNYXAgdXNlcyBhIGhhc2h0YWJsZSB1bmRlciB0aGUgaG9vZCwgc28gdGhlIGxvb2t1cFxuLy8gY29tcGxleGl0eSBpcyBhbG1vc3QgTygxKS5cbnZhciB0YWJsZSA9IG5ldyBXZWFrTWFwKCk7XG4vLyBjb3VudGVyIG9mIHRoZSBrZXlcbnZhciBjb3VudGVyID0gMDtcbi8vIGhhc2hlcyBhbiBhcnJheSBvZiBvYmplY3RzIGFuZCByZXR1cm5zIGEgc3RyaW5nXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBoYXNoKGFyZ3MpIHtcbiAgICBpZiAoIWFyZ3MubGVuZ3RoKVxuICAgICAgICByZXR1cm4gJyc7XG4gICAgdmFyIGtleSA9ICdhcmcnO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJncy5sZW5ndGg7ICsraSkge1xuICAgICAgICBpZiAoYXJnc1tpXSA9PT0gbnVsbCkge1xuICAgICAgICAgICAga2V5ICs9ICdAbnVsbCc7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgX2hhc2ggPSB2b2lkIDA7XG4gICAgICAgIGlmICh0eXBlb2YgYXJnc1tpXSAhPT0gJ29iamVjdCcgJiYgdHlwZW9mIGFyZ3NbaV0gIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIC8vIG5lZWQgdG8gY29uc2lkZXIgdGhlIGNhc2UgdGhhdCBhcmdzW2ldIGlzIGEgc3RyaW5nOlxuICAgICAgICAgICAgLy8gYXJnc1tpXSAgICAgICAgX2hhc2hcbiAgICAgICAgICAgIC8vIFwidW5kZWZpbmVkXCIgLT4gJ1widW5kZWZpbmVkXCInXG4gICAgICAgICAgICAvLyB1bmRlZmluZWQgICAtPiAndW5kZWZpbmVkJ1xuICAgICAgICAgICAgLy8gMTIzICAgICAgICAgLT4gJzEyMydcbiAgICAgICAgICAgIC8vIFwibnVsbFwiICAgICAgLT4gJ1wibnVsbFwiJ1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBhcmdzW2ldID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgIF9oYXNoID0gJ1wiJyArIGFyZ3NbaV0gKyAnXCInO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgX2hhc2ggPSBTdHJpbmcoYXJnc1tpXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpZiAoIXRhYmxlLmhhcyhhcmdzW2ldKSkge1xuICAgICAgICAgICAgICAgIF9oYXNoID0gY291bnRlcjtcbiAgICAgICAgICAgICAgICB0YWJsZS5zZXQoYXJnc1tpXSwgY291bnRlcisrKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIF9oYXNoID0gdGFibGUuZ2V0KGFyZ3NbaV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGtleSArPSAnQCcgKyBfaGFzaDtcbiAgICB9XG4gICAgcmV0dXJuIGtleTtcbn1cbiIsIi8qKlxuICogRHVlIHRvIGJ1ZyBodHRwczovL2J1Z3MuY2hyb21pdW0ub3JnL3AvY2hyb21pdW0vaXNzdWVzL2RldGFpbD9pZD02NzgwNzUsXG4gKiBpdCdzIG5vdCByZWxpYWJsZSB0byBkZXRlY3QgaWYgdGhlIGJyb3dzZXIgaXMgY3VycmVudGx5IG9ubGluZSBvciBvZmZsaW5lXG4gKiBiYXNlZCBvbiBgbmF2aWdhdG9yLm9uTGluZWAuXG4gKiBBcyBhIHdvcmsgYXJvdW5kLCB3ZSBhbHdheXMgYXNzdW1lIGl0J3Mgb25saW5lIG9uIGZpcnN0IGxvYWQsIGFuZCBjaGFuZ2VcbiAqIHRoZSBzdGF0dXMgdXBvbiBgb25saW5lYCBvciBgb2ZmbGluZWAgZXZlbnRzLlxuICovXG52YXIgb25saW5lID0gdHJ1ZTtcbnZhciBpc09ubGluZSA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIG9ubGluZTsgfTtcbnZhciBpc0RvY3VtZW50VmlzaWJsZSA9IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAodHlwZW9mIGRvY3VtZW50ICE9PSAndW5kZWZpbmVkJyAmJlxuICAgICAgICBkb2N1bWVudC52aXNpYmlsaXR5U3RhdGUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gZG9jdW1lbnQudmlzaWJpbGl0eVN0YXRlICE9PSAnaGlkZGVuJztcbiAgICB9XG4gICAgLy8gYWx3YXlzIGFzc3VtZSBpdCdzIHZpc2libGVcbiAgICByZXR1cm4gdHJ1ZTtcbn07XG52YXIgZmV0Y2hlciA9IGZ1bmN0aW9uICh1cmwpIHsgcmV0dXJuIGZldGNoKHVybCkudGhlbihmdW5jdGlvbiAocmVzKSB7IHJldHVybiByZXMuanNvbigpOyB9KTsgfTtcbnZhciByZWdpc3Rlck9uRm9jdXMgPSBmdW5jdGlvbiAoY2IpIHtcbiAgICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiZcbiAgICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIgIT09IHVuZGVmaW5lZCAmJlxuICAgICAgICB0eXBlb2YgZG9jdW1lbnQgIT09ICd1bmRlZmluZWQnICYmXG4gICAgICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAvLyBmb2N1cyByZXZhbGlkYXRlXG4gICAgICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ3Zpc2liaWxpdHljaGFuZ2UnLCBmdW5jdGlvbiAoKSB7IHJldHVybiBjYigpOyB9LCBmYWxzZSk7XG4gICAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdmb2N1cycsIGZ1bmN0aW9uICgpIHsgcmV0dXJuIGNiKCk7IH0sIGZhbHNlKTtcbiAgICB9XG59O1xudmFyIHJlZ2lzdGVyT25SZWNvbm5lY3QgPSBmdW5jdGlvbiAoY2IpIHtcbiAgICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAvLyByZWNvbm5lY3QgcmV2YWxpZGF0ZVxuICAgICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcignb25saW5lJywgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgb25saW5lID0gdHJ1ZTtcbiAgICAgICAgICAgIGNiKCk7XG4gICAgICAgIH0sIGZhbHNlKTtcbiAgICAgICAgLy8gbm90aGluZyB0byByZXZhbGlkYXRlLCBqdXN0IHVwZGF0ZSB0aGUgc3RhdHVzXG4gICAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdvZmZsaW5lJywgZnVuY3Rpb24gKCkgeyByZXR1cm4gKG9ubGluZSA9IGZhbHNlKTsgfSwgZmFsc2UpO1xuICAgIH1cbn07XG5leHBvcnQgZGVmYXVsdCB7XG4gICAgaXNPbmxpbmU6IGlzT25saW5lLFxuICAgIGlzRG9jdW1lbnRWaXNpYmxlOiBpc0RvY3VtZW50VmlzaWJsZSxcbiAgICBmZXRjaGVyOiBmZXRjaGVyLFxuICAgIHJlZ2lzdGVyT25Gb2N1czogcmVnaXN0ZXJPbkZvY3VzLFxuICAgIHJlZ2lzdGVyT25SZWNvbm5lY3Q6IHJlZ2lzdGVyT25SZWNvbm5lY3Rcbn07XG4iLCJpbXBvcnQgeyBjcmVhdGVDb250ZXh0IH0gZnJvbSAncmVhY3QnO1xudmFyIFNXUkNvbmZpZ0NvbnRleHQgPSBjcmVhdGVDb250ZXh0KHt9KTtcblNXUkNvbmZpZ0NvbnRleHQuZGlzcGxheU5hbWUgPSAnU1dSQ29uZmlnQ29udGV4dCc7XG5leHBvcnQgZGVmYXVsdCBTV1JDb25maWdDb250ZXh0O1xuIiwidmFyIF9fYXdhaXRlciA9ICh0aGlzICYmIHRoaXMuX19hd2FpdGVyKSB8fCBmdW5jdGlvbiAodGhpc0FyZywgX2FyZ3VtZW50cywgUCwgZ2VuZXJhdG9yKSB7XG4gICAgZnVuY3Rpb24gYWRvcHQodmFsdWUpIHsgcmV0dXJuIHZhbHVlIGluc3RhbmNlb2YgUCA/IHZhbHVlIDogbmV3IFAoZnVuY3Rpb24gKHJlc29sdmUpIHsgcmVzb2x2ZSh2YWx1ZSk7IH0pOyB9XG4gICAgcmV0dXJuIG5ldyAoUCB8fCAoUCA9IFByb21pc2UpKShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgIGZ1bmN0aW9uIGZ1bGZpbGxlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvci5uZXh0KHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cbiAgICAgICAgZnVuY3Rpb24gcmVqZWN0ZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3JbXCJ0aHJvd1wiXSh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XG4gICAgICAgIGZ1bmN0aW9uIHN0ZXAocmVzdWx0KSB7IHJlc3VsdC5kb25lID8gcmVzb2x2ZShyZXN1bHQudmFsdWUpIDogYWRvcHQocmVzdWx0LnZhbHVlKS50aGVuKGZ1bGZpbGxlZCwgcmVqZWN0ZWQpOyB9XG4gICAgICAgIHN0ZXAoKGdlbmVyYXRvciA9IGdlbmVyYXRvci5hcHBseSh0aGlzQXJnLCBfYXJndW1lbnRzIHx8IFtdKSkubmV4dCgpKTtcbiAgICB9KTtcbn07XG52YXIgX19nZW5lcmF0b3IgPSAodGhpcyAmJiB0aGlzLl9fZ2VuZXJhdG9yKSB8fCBmdW5jdGlvbiAodGhpc0FyZywgYm9keSkge1xuICAgIHZhciBfID0geyBsYWJlbDogMCwgc2VudDogZnVuY3Rpb24oKSB7IGlmICh0WzBdICYgMSkgdGhyb3cgdFsxXTsgcmV0dXJuIHRbMV07IH0sIHRyeXM6IFtdLCBvcHM6IFtdIH0sIGYsIHksIHQsIGc7XG4gICAgcmV0dXJuIGcgPSB7IG5leHQ6IHZlcmIoMCksIFwidGhyb3dcIjogdmVyYigxKSwgXCJyZXR1cm5cIjogdmVyYigyKSB9LCB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgKGdbU3ltYm9sLml0ZXJhdG9yXSA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gdGhpczsgfSksIGc7XG4gICAgZnVuY3Rpb24gdmVyYihuKSB7IHJldHVybiBmdW5jdGlvbiAodikgeyByZXR1cm4gc3RlcChbbiwgdl0pOyB9OyB9XG4gICAgZnVuY3Rpb24gc3RlcChvcCkge1xuICAgICAgICBpZiAoZikgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkdlbmVyYXRvciBpcyBhbHJlYWR5IGV4ZWN1dGluZy5cIik7XG4gICAgICAgIHdoaWxlIChfKSB0cnkge1xuICAgICAgICAgICAgaWYgKGYgPSAxLCB5ICYmICh0ID0gb3BbMF0gJiAyID8geVtcInJldHVyblwiXSA6IG9wWzBdID8geVtcInRocm93XCJdIHx8ICgodCA9IHlbXCJyZXR1cm5cIl0pICYmIHQuY2FsbCh5KSwgMCkgOiB5Lm5leHQpICYmICEodCA9IHQuY2FsbCh5LCBvcFsxXSkpLmRvbmUpIHJldHVybiB0O1xuICAgICAgICAgICAgaWYgKHkgPSAwLCB0KSBvcCA9IFtvcFswXSAmIDIsIHQudmFsdWVdO1xuICAgICAgICAgICAgc3dpdGNoIChvcFswXSkge1xuICAgICAgICAgICAgICAgIGNhc2UgMDogY2FzZSAxOiB0ID0gb3A7IGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgNDogXy5sYWJlbCsrOyByZXR1cm4geyB2YWx1ZTogb3BbMV0sIGRvbmU6IGZhbHNlIH07XG4gICAgICAgICAgICAgICAgY2FzZSA1OiBfLmxhYmVsKys7IHkgPSBvcFsxXTsgb3AgPSBbMF07IGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIGNhc2UgNzogb3AgPSBfLm9wcy5wb3AoKTsgXy50cnlzLnBvcCgpOyBjb250aW51ZTtcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICBpZiAoISh0ID0gXy50cnlzLCB0ID0gdC5sZW5ndGggPiAwICYmIHRbdC5sZW5ndGggLSAxXSkgJiYgKG9wWzBdID09PSA2IHx8IG9wWzBdID09PSAyKSkgeyBfID0gMDsgY29udGludWU7IH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKG9wWzBdID09PSAzICYmICghdCB8fCAob3BbMV0gPiB0WzBdICYmIG9wWzFdIDwgdFszXSkpKSB7IF8ubGFiZWwgPSBvcFsxXTsgYnJlYWs7IH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKG9wWzBdID09PSA2ICYmIF8ubGFiZWwgPCB0WzFdKSB7IF8ubGFiZWwgPSB0WzFdOyB0ID0gb3A7IGJyZWFrOyB9XG4gICAgICAgICAgICAgICAgICAgIGlmICh0ICYmIF8ubGFiZWwgPCB0WzJdKSB7IF8ubGFiZWwgPSB0WzJdOyBfLm9wcy5wdXNoKG9wKTsgYnJlYWs7IH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKHRbMl0pIF8ub3BzLnBvcCgpO1xuICAgICAgICAgICAgICAgICAgICBfLnRyeXMucG9wKCk7IGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgb3AgPSBib2R5LmNhbGwodGhpc0FyZywgXyk7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHsgb3AgPSBbNiwgZV07IHkgPSAwOyB9IGZpbmFsbHkgeyBmID0gdCA9IDA7IH1cbiAgICAgICAgaWYgKG9wWzBdICYgNSkgdGhyb3cgb3BbMV07IHJldHVybiB7IHZhbHVlOiBvcFswXSA/IG9wWzFdIDogdm9pZCAwLCBkb25lOiB0cnVlIH07XG4gICAgfVxufTtcbnZhciBfX3Jlc3QgPSAodGhpcyAmJiB0aGlzLl9fcmVzdCkgfHwgZnVuY3Rpb24gKHMsIGUpIHtcbiAgICB2YXIgdCA9IHt9O1xuICAgIGZvciAodmFyIHAgaW4gcykgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzLCBwKSAmJiBlLmluZGV4T2YocCkgPCAwKVxuICAgICAgICB0W3BdID0gc1twXTtcbiAgICBpZiAocyAhPSBudWxsICYmIHR5cGVvZiBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzID09PSBcImZ1bmN0aW9uXCIpXG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBwID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhzKTsgaSA8IHAubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGlmIChlLmluZGV4T2YocFtpXSkgPCAwICYmIE9iamVjdC5wcm90b3R5cGUucHJvcGVydHlJc0VudW1lcmFibGUuY2FsbChzLCBwW2ldKSlcbiAgICAgICAgICAgICAgICB0W3BbaV1dID0gc1twW2ldXTtcbiAgICAgICAgfVxuICAgIHJldHVybiB0O1xufTtcbi8vIFRPRE86IHVzZSBAdHMtZXhwZWN0LWVycm9yXG5pbXBvcnQgeyB1c2VDb250ZXh0LCB1c2VSZWYsIHVzZVN0YXRlLCB1c2VDYWxsYmFjayB9IGZyb20gJ3JlYWN0JztcbmltcG9ydCBkZWZhdWx0Q29uZmlnLCB7IGNhY2hlIH0gZnJvbSAnLi9jb25maWcnO1xuaW1wb3J0IHsgdXNlSXNvbW9ycGhpY0xheW91dEVmZmVjdCB9IGZyb20gJy4vZW52JztcbmltcG9ydCBTV1JDb25maWdDb250ZXh0IGZyb20gJy4vc3dyLWNvbmZpZy1jb250ZXh0JztcbmltcG9ydCB1c2VTV1IgZnJvbSAnLi91c2Utc3dyJztcbmZ1bmN0aW9uIHVzZVNXUkluZmluaXRlKCkge1xuICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgdmFyIGFyZ3MgPSBbXTtcbiAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgYXJndW1lbnRzLmxlbmd0aDsgX2krKykge1xuICAgICAgICBhcmdzW19pXSA9IGFyZ3VtZW50c1tfaV07XG4gICAgfVxuICAgIHZhciBnZXRLZXkgPSBhcmdzWzBdO1xuICAgIHZhciBjb25maWcgPSBPYmplY3QuYXNzaWduKHt9LCBkZWZhdWx0Q29uZmlnLCB1c2VDb250ZXh0KFNXUkNvbmZpZ0NvbnRleHQpLCBhcmdzLmxlbmd0aCA+IDJcbiAgICAgICAgPyBhcmdzWzJdXG4gICAgICAgIDogYXJncy5sZW5ndGggPT09IDIgJiYgdHlwZW9mIGFyZ3NbMV0gPT09ICdvYmplY3QnXG4gICAgICAgICAgICA/IGFyZ3NbMV1cbiAgICAgICAgICAgIDoge30pO1xuICAgIC8vIGluIHR5cGVzY3JpcHQgYXJncy5sZW5ndGggPiAyIGlzIG5vdCBzYW1lIGFzIGFyZ3MubGVudGggPT09IDNcbiAgICAvLyB3ZSBkbyBhIHNhZmUgdHlwZSBhc3NlcnRpb24gaGVyZVxuICAgIC8vIGFyZ3MubGVuZ3RoID09PSAzXG4gICAgdmFyIGZuID0gKGFyZ3MubGVuZ3RoID4gMlxuICAgICAgICA/IGFyZ3NbMV1cbiAgICAgICAgOiBhcmdzLmxlbmd0aCA9PT0gMiAmJiB0eXBlb2YgYXJnc1sxXSA9PT0gJ2Z1bmN0aW9uJ1xuICAgICAgICAgICAgPyBhcmdzWzFdXG4gICAgICAgICAgICA6IGNvbmZpZy5mZXRjaGVyKTtcbiAgICB2YXIgX2EgPSBjb25maWcuaW5pdGlhbFNpemUsIGluaXRpYWxTaXplID0gX2EgPT09IHZvaWQgMCA/IDEgOiBfYSwgX2IgPSBjb25maWcucmV2YWxpZGF0ZUFsbCwgcmV2YWxpZGF0ZUFsbCA9IF9iID09PSB2b2lkIDAgPyBmYWxzZSA6IF9iLCBfYyA9IGNvbmZpZy5wZXJzaXN0U2l6ZSwgcGVyc2lzdFNpemUgPSBfYyA9PT0gdm9pZCAwID8gZmFsc2UgOiBfYywgZXh0cmFDb25maWcgPSBfX3Jlc3QoY29uZmlnXG4gICAgLy8gZ2V0IHRoZSBzZXJpYWxpemVkIGtleSBvZiB0aGUgZmlyc3QgcGFnZVxuICAgICwgW1wiaW5pdGlhbFNpemVcIiwgXCJyZXZhbGlkYXRlQWxsXCIsIFwicGVyc2lzdFNpemVcIl0pO1xuICAgIC8vIGdldCB0aGUgc2VyaWFsaXplZCBrZXkgb2YgdGhlIGZpcnN0IHBhZ2VcbiAgICB2YXIgZmlyc3RQYWdlS2V5ID0gbnVsbDtcbiAgICB0cnkge1xuICAgICAgICA7XG4gICAgICAgIGZpcnN0UGFnZUtleSA9IGNhY2hlLnNlcmlhbGl6ZUtleShnZXRLZXkoMCwgbnVsbCkpWzBdO1xuICAgIH1cbiAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgIC8vIG5vdCByZWFkeVxuICAgIH1cbiAgICB2YXIgcmVyZW5kZXIgPSB1c2VTdGF0ZSh7fSlbMV07XG4gICAgLy8gd2UgdXNlIGNhY2hlIHRvIHBhc3MgZXh0cmEgaW5mbyAoY29udGV4dCkgdG8gZmV0Y2hlciBzbyBpdCBjYW4gYmUgZ2xvYmFsbHkgc2hhcmVkXG4gICAgLy8gaGVyZSB3ZSBnZXQgdGhlIGtleSBvZiB0aGUgZmV0Y2hlciBjb250ZXh0IGNhY2hlXG4gICAgdmFyIGNvbnRleHRDYWNoZUtleSA9IG51bGw7XG4gICAgaWYgKGZpcnN0UGFnZUtleSkge1xuICAgICAgICBjb250ZXh0Q2FjaGVLZXkgPSAnY3R4QCcgKyBmaXJzdFBhZ2VLZXk7XG4gICAgfVxuICAgIC8vIHBhZ2Ugc2l6ZSBpcyBhbHNvIGNhY2hlZCB0byBzaGFyZSB0aGUgcGFnZSBkYXRhIGJldHdlZW4gaG9va3MgaGF2aW5nIHRoZSBzYW1lIGtleVxuICAgIHZhciBwYWdlU2l6ZUNhY2hlS2V5ID0gbnVsbDtcbiAgICBpZiAoZmlyc3RQYWdlS2V5KSB7XG4gICAgICAgIHBhZ2VTaXplQ2FjaGVLZXkgPSAnbGVuQCcgKyBmaXJzdFBhZ2VLZXk7XG4gICAgfVxuICAgIHZhciBkaWRNb3VudFJlZiA9IHVzZVJlZihmYWxzZSk7XG4gICAgdmFyIHJlc29sdmVQYWdlU2l6ZSA9IHVzZUNhbGxiYWNrKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGNhY2hlZFBhZ2VTaXplID0gY2FjaGUuZ2V0KHBhZ2VTaXplQ2FjaGVLZXkpO1xuICAgICAgICByZXR1cm4gdHlwZW9mIGNhY2hlZFBhZ2VTaXplICE9PSAndW5kZWZpbmVkJyA/IGNhY2hlZFBhZ2VTaXplIDogaW5pdGlhbFNpemU7XG4gICAgfSwgW3BhZ2VTaXplQ2FjaGVLZXksIGluaXRpYWxTaXplXSk7XG4gICAgLy8ga2VlcCB0aGUgbGFzdCBwYWdlIHNpemUgdG8gcmVzdG9yZSBpdCB3aXRoIHRoZSBwZXJzaXN0U2l6ZSBvcHRpb25cbiAgICB2YXIgbGFzdFBhZ2VTaXplUmVmID0gdXNlUmVmKHJlc29sdmVQYWdlU2l6ZSgpKTtcbiAgICAvLyBldmVyeSB0aW1lIHRoZSBrZXkgY2hhbmdlcywgd2UgcmVzZXQgdGhlIHBhZ2Ugc2l6ZSBpZiBpdCdzIG5vdCBwZXJzaXN0ZWRcbiAgICB1c2VJc29tb3JwaGljTGF5b3V0RWZmZWN0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKCFkaWRNb3VudFJlZi5jdXJyZW50KSB7XG4gICAgICAgICAgICBkaWRNb3VudFJlZi5jdXJyZW50ID0gdHJ1ZTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICAvLyBJZiB0aGUga2V5IGhhcyBiZWVuIGNoYW5nZWQsIHdlIGtlZXAgdGhlIGN1cnJlbnQgcGFnZSBzaXplIGlmIHBlcnNpc3RTaXplIGlzIGVuYWJsZWRcbiAgICAgICAgY2FjaGUuc2V0KHBhZ2VTaXplQ2FjaGVLZXksIHBlcnNpc3RTaXplID8gbGFzdFBhZ2VTaXplUmVmLmN1cnJlbnQgOiBpbml0aWFsU2l6ZSk7XG4gICAgICAgIC8vIGluaXRpYWxTaXplIGlzbid0IGFsbG93ZWQgdG8gY2hhbmdlIGR1cmluZyB0aGUgbGlmZWN5Y2xlXG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZWFjdC1ob29rcy9leGhhdXN0aXZlLWRlcHNcbiAgICB9LCBbZmlyc3RQYWdlS2V5XSk7XG4gICAgLy8ga2VlcCB0aGUgZGF0YSBpbnNpZGUgYSByZWZcbiAgICB2YXIgZGF0YVJlZiA9IHVzZVJlZigpO1xuICAgIC8vIGFjdHVhbCBzd3Igb2YgYWxsIHBhZ2VzXG4gICAgdmFyIHN3ciA9IHVzZVNXUihmaXJzdFBhZ2VLZXkgPyBbJ2luZicsIGZpcnN0UGFnZUtleV0gOiBudWxsLCBmdW5jdGlvbiAoKSB7IHJldHVybiBfX2F3YWl0ZXIoX3RoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfYSwgb3JpZ2luYWxEYXRhLCBmb3JjZSwgZGF0YSwgcGFnZVNpemUsIHByZXZpb3VzUGFnZURhdGEsIGksIF9iLCBwYWdlS2V5LCBwYWdlQXJncywgcGFnZURhdGEsIHNob3VsZEZldGNoUGFnZTtcbiAgICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYykge1xuICAgICAgICAgICAgc3dpdGNoIChfYy5sYWJlbCkge1xuICAgICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICAgICAgX2EgPSBjYWNoZS5nZXQoY29udGV4dENhY2hlS2V5KSB8fCB7fSwgb3JpZ2luYWxEYXRhID0gX2EuZGF0YSwgZm9yY2UgPSBfYS5mb3JjZTtcbiAgICAgICAgICAgICAgICAgICAgZGF0YSA9IFtdO1xuICAgICAgICAgICAgICAgICAgICBwYWdlU2l6ZSA9IHJlc29sdmVQYWdlU2l6ZSgpO1xuICAgICAgICAgICAgICAgICAgICBwcmV2aW91c1BhZ2VEYXRhID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgaSA9IDA7XG4gICAgICAgICAgICAgICAgICAgIF9jLmxhYmVsID0gMTtcbiAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgIGlmICghKGkgPCBwYWdlU2l6ZSkpIHJldHVybiBbMyAvKmJyZWFrKi8sIDhdO1xuICAgICAgICAgICAgICAgICAgICBfYiA9IGNhY2hlLnNlcmlhbGl6ZUtleShnZXRLZXkoaSwgcHJldmlvdXNQYWdlRGF0YSkpLCBwYWdlS2V5ID0gX2JbMF0sIHBhZ2VBcmdzID0gX2JbMV07XG4gICAgICAgICAgICAgICAgICAgIGlmICghcGFnZUtleSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gcGFnZUtleSBpcyBmYWxzeSwgc3RvcCBmZXRjaGluZyBuZXh0IHBhZ2VzXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzMgLypicmVhayovLCA4XTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBwYWdlRGF0YSA9IGNhY2hlLmdldChwYWdlS2V5KTtcbiAgICAgICAgICAgICAgICAgICAgc2hvdWxkRmV0Y2hQYWdlID0gcmV2YWxpZGF0ZUFsbCB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgZm9yY2UgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGVvZiBwYWdlRGF0YSA9PT0gJ3VuZGVmaW5lZCcgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICh0eXBlb2YgZm9yY2UgPT09ICd1bmRlZmluZWQnICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaSA9PT0gMCAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGVvZiBkYXRhUmVmLmN1cnJlbnQgIT09ICd1bmRlZmluZWQnKSB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgKG9yaWdpbmFsRGF0YSAmJiAhY29uZmlnLmNvbXBhcmUob3JpZ2luYWxEYXRhW2ldLCBwYWdlRGF0YSkpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIXNob3VsZEZldGNoUGFnZSkgcmV0dXJuIFszIC8qYnJlYWsqLywgNl07XG4gICAgICAgICAgICAgICAgICAgIGlmICghKHBhZ2VBcmdzICE9PSBudWxsKSkgcmV0dXJuIFszIC8qYnJlYWsqLywgM107XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCAvKnlpZWxkKi8sIGZuLmFwcGx5KHZvaWQgMCwgcGFnZUFyZ3MpXTtcbiAgICAgICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgICAgIHBhZ2VEYXRhID0gX2Muc2VudCgpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzMgLypicmVhayovLCA1XTtcbiAgICAgICAgICAgICAgICBjYXNlIDM6IHJldHVybiBbNCAvKnlpZWxkKi8sIGZuKHBhZ2VLZXkpXTtcbiAgICAgICAgICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgICAgICAgICAgIHBhZ2VEYXRhID0gX2Muc2VudCgpO1xuICAgICAgICAgICAgICAgICAgICBfYy5sYWJlbCA9IDU7XG4gICAgICAgICAgICAgICAgY2FzZSA1OlxuICAgICAgICAgICAgICAgICAgICBjYWNoZS5zZXQocGFnZUtleSwgcGFnZURhdGEpO1xuICAgICAgICAgICAgICAgICAgICBfYy5sYWJlbCA9IDY7XG4gICAgICAgICAgICAgICAgY2FzZSA2OlxuICAgICAgICAgICAgICAgICAgICBkYXRhLnB1c2gocGFnZURhdGEpO1xuICAgICAgICAgICAgICAgICAgICBwcmV2aW91c1BhZ2VEYXRhID0gcGFnZURhdGE7XG4gICAgICAgICAgICAgICAgICAgIF9jLmxhYmVsID0gNztcbiAgICAgICAgICAgICAgICBjYXNlIDc6XG4gICAgICAgICAgICAgICAgICAgICsraTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFszIC8qYnJlYWsqLywgMV07XG4gICAgICAgICAgICAgICAgY2FzZSA4OlxuICAgICAgICAgICAgICAgICAgICAvLyBvbmNlIHdlIGV4ZWN1dGVkIHRoZSBkYXRhIGZldGNoaW5nIGJhc2VkIG9uIHRoZSBjb250ZXh0LCBjbGVhciB0aGUgY29udGV4dFxuICAgICAgICAgICAgICAgICAgICBjYWNoZS5kZWxldGUoY29udGV4dENhY2hlS2V5KTtcbiAgICAgICAgICAgICAgICAgICAgLy8gcmV0dXJuIHRoZSBkYXRhXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovLCBkYXRhXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfSk7IH0sIGV4dHJhQ29uZmlnKTtcbiAgICAvLyB1cGRhdGUgZGF0YVJlZlxuICAgIHVzZUlzb21vcnBoaWNMYXlvdXRFZmZlY3QoZnVuY3Rpb24gKCkge1xuICAgICAgICBkYXRhUmVmLmN1cnJlbnQgPSBzd3IuZGF0YTtcbiAgICB9LCBbc3dyLmRhdGFdKTtcbiAgICB2YXIgbXV0YXRlID0gdXNlQ2FsbGJhY2soZnVuY3Rpb24gKGRhdGEsIHNob3VsZFJldmFsaWRhdGUpIHtcbiAgICAgICAgaWYgKHNob3VsZFJldmFsaWRhdGUgPT09IHZvaWQgMCkgeyBzaG91bGRSZXZhbGlkYXRlID0gdHJ1ZTsgfVxuICAgICAgICBpZiAoc2hvdWxkUmV2YWxpZGF0ZSAmJiB0eXBlb2YgZGF0YSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIC8vIHdlIG9ubHkgcmV2YWxpZGF0ZSB0aGUgcGFnZXMgdGhhdCBhcmUgY2hhbmdlZFxuICAgICAgICAgICAgdmFyIG9yaWdpbmFsRGF0YSA9IGRhdGFSZWYuY3VycmVudDtcbiAgICAgICAgICAgIGNhY2hlLnNldChjb250ZXh0Q2FjaGVLZXksIHsgZGF0YTogb3JpZ2luYWxEYXRhLCBmb3JjZTogZmFsc2UgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoc2hvdWxkUmV2YWxpZGF0ZSkge1xuICAgICAgICAgICAgLy8gY2FsbGluZyBgbXV0YXRlKClgLCB3ZSByZXZhbGlkYXRlIGFsbCBwYWdlc1xuICAgICAgICAgICAgY2FjaGUuc2V0KGNvbnRleHRDYWNoZUtleSwgeyBmb3JjZTogdHJ1ZSB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc3dyLm11dGF0ZShkYXRhLCBzaG91bGRSZXZhbGlkYXRlKTtcbiAgICB9LCBcbiAgICAvLyBzd3IubXV0YXRlIGlzIGFsd2F5cyB0aGUgc2FtZSByZWZlcmVuY2VcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3QtaG9va3MvZXhoYXVzdGl2ZS1kZXBzXG4gICAgW2NvbnRleHRDYWNoZUtleV0pO1xuICAgIC8vIGV4dGVuZCB0aGUgU1dSIEFQSVxuICAgIHZhciBzZXRTaXplID0gdXNlQ2FsbGJhY2soZnVuY3Rpb24gKGFyZykge1xuICAgICAgICB2YXIgc2l6ZTtcbiAgICAgICAgaWYgKHR5cGVvZiBhcmcgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIHNpemUgPSBhcmcocmVzb2x2ZVBhZ2VTaXplKCkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHR5cGVvZiBhcmcgPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICBzaXplID0gYXJnO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2Ygc2l6ZSA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgIGNhY2hlLnNldChwYWdlU2l6ZUNhY2hlS2V5LCBzaXplKTtcbiAgICAgICAgICAgIGxhc3RQYWdlU2l6ZVJlZi5jdXJyZW50ID0gc2l6ZTtcbiAgICAgICAgfVxuICAgICAgICByZXJlbmRlcih7fSk7XG4gICAgICAgIHJldHVybiBtdXRhdGUoZnVuY3Rpb24gKHYpIHsgcmV0dXJuIHY7IH0pO1xuICAgIH0sIFxuICAgIC8vIGltbXV0YWJpbGl0eSBvZiByZXJlbmRlciBpcyBndWFyYW50ZWVkIGJ5IFJlYWN0LCBidXQgcmVhY3QtaG9va3MvZXhoYXVzdGl2ZS1kZXBzIGRvZXNuJ3QgcmVjb2duaXplIGl0XG4gICAgLy8gZnJvbSBgcmVyZW5kZXIgPSB1c2VTdGF0ZSh7fSlbMV0sIHNvIHdlIHB1dCByZXJlbmRlciBoZXJlXG4gICAgW3BhZ2VTaXplQ2FjaGVLZXksIHJlc29sdmVQYWdlU2l6ZSwgbXV0YXRlLCByZXJlbmRlcl0pO1xuICAgIC8vIFVzZSBnZXR0ZXIgZnVuY3Rpb25zIHRvIGF2b2lkIHVubmVjZXNzYXJ5IHJlLXJlbmRlcnMgY2F1c2VkIGJ5IHRyaWdnZXJpbmcgYWxsIHRoZSBnZXR0ZXJzIG9mIHRoZSByZXR1cm5lZCBzd3Igb2JqZWN0XG4gICAgdmFyIHN3ckluZmluaXRlID0geyBzaXplOiByZXNvbHZlUGFnZVNpemUoKSwgc2V0U2l6ZTogc2V0U2l6ZSwgbXV0YXRlOiBtdXRhdGUgfTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhzd3JJbmZpbml0ZSwge1xuICAgICAgICBlcnJvcjoge1xuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBzd3IuZXJyb3I7IH0sXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlXG4gICAgICAgIH0sXG4gICAgICAgIGRhdGE6IHtcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gc3dyLmRhdGE7IH0sXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlXG4gICAgICAgIH0sXG4gICAgICAgIC8vIHJldmFsaWRhdGUgd2lsbCBiZSBkZXByZWNhdGVkIGluIHRoZSAxLnggcmVsZWFzZVxuICAgICAgICAvLyBiZWNhdXNlIG11dGF0ZSgpIGNvdmVycyB0aGUgc2FtZSB1c2UgY2FzZSBvZiByZXZhbGlkYXRlKCkuXG4gICAgICAgIC8vIFRoaXMgcmVtYWlucyBvbmx5IGZvciBiYWNrd2FyZCBjb21wYXRpYmlsaXR5XG4gICAgICAgIHJldmFsaWRhdGU6IHtcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gc3dyLnJldmFsaWRhdGU7IH0sXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlXG4gICAgICAgIH0sXG4gICAgICAgIGlzVmFsaWRhdGluZzoge1xuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBzd3IuaXNWYWxpZGF0aW5nOyB9LFxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZVxuICAgICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIHN3ckluZmluaXRlO1xufVxuZXhwb3J0IHsgdXNlU1dSSW5maW5pdGUgfTtcbiIsInZhciBfX2F3YWl0ZXIgPSAodGhpcyAmJiB0aGlzLl9fYXdhaXRlcikgfHwgZnVuY3Rpb24gKHRoaXNBcmcsIF9hcmd1bWVudHMsIFAsIGdlbmVyYXRvcikge1xuICAgIGZ1bmN0aW9uIGFkb3B0KHZhbHVlKSB7IHJldHVybiB2YWx1ZSBpbnN0YW5jZW9mIFAgPyB2YWx1ZSA6IG5ldyBQKGZ1bmN0aW9uIChyZXNvbHZlKSB7IHJlc29sdmUodmFsdWUpOyB9KTsgfVxuICAgIHJldHVybiBuZXcgKFAgfHwgKFAgPSBQcm9taXNlKSkoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICBmdW5jdGlvbiBmdWxmaWxsZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3IubmV4dCh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XG4gICAgICAgIGZ1bmN0aW9uIHJlamVjdGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yW1widGhyb3dcIl0odmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxuICAgICAgICBmdW5jdGlvbiBzdGVwKHJlc3VsdCkgeyByZXN1bHQuZG9uZSA/IHJlc29sdmUocmVzdWx0LnZhbHVlKSA6IGFkb3B0KHJlc3VsdC52YWx1ZSkudGhlbihmdWxmaWxsZWQsIHJlamVjdGVkKTsgfVxuICAgICAgICBzdGVwKChnZW5lcmF0b3IgPSBnZW5lcmF0b3IuYXBwbHkodGhpc0FyZywgX2FyZ3VtZW50cyB8fCBbXSkpLm5leHQoKSk7XG4gICAgfSk7XG59O1xudmFyIF9fZ2VuZXJhdG9yID0gKHRoaXMgJiYgdGhpcy5fX2dlbmVyYXRvcikgfHwgZnVuY3Rpb24gKHRoaXNBcmcsIGJvZHkpIHtcbiAgICB2YXIgXyA9IHsgbGFiZWw6IDAsIHNlbnQ6IGZ1bmN0aW9uKCkgeyBpZiAodFswXSAmIDEpIHRocm93IHRbMV07IHJldHVybiB0WzFdOyB9LCB0cnlzOiBbXSwgb3BzOiBbXSB9LCBmLCB5LCB0LCBnO1xuICAgIHJldHVybiBnID0geyBuZXh0OiB2ZXJiKDApLCBcInRocm93XCI6IHZlcmIoMSksIFwicmV0dXJuXCI6IHZlcmIoMikgfSwgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIChnW1N5bWJvbC5pdGVyYXRvcl0gPSBmdW5jdGlvbigpIHsgcmV0dXJuIHRoaXM7IH0pLCBnO1xuICAgIGZ1bmN0aW9uIHZlcmIobikgeyByZXR1cm4gZnVuY3Rpb24gKHYpIHsgcmV0dXJuIHN0ZXAoW24sIHZdKTsgfTsgfVxuICAgIGZ1bmN0aW9uIHN0ZXAob3ApIHtcbiAgICAgICAgaWYgKGYpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJHZW5lcmF0b3IgaXMgYWxyZWFkeSBleGVjdXRpbmcuXCIpO1xuICAgICAgICB3aGlsZSAoXykgdHJ5IHtcbiAgICAgICAgICAgIGlmIChmID0gMSwgeSAmJiAodCA9IG9wWzBdICYgMiA/IHlbXCJyZXR1cm5cIl0gOiBvcFswXSA/IHlbXCJ0aHJvd1wiXSB8fCAoKHQgPSB5W1wicmV0dXJuXCJdKSAmJiB0LmNhbGwoeSksIDApIDogeS5uZXh0KSAmJiAhKHQgPSB0LmNhbGwoeSwgb3BbMV0pKS5kb25lKSByZXR1cm4gdDtcbiAgICAgICAgICAgIGlmICh5ID0gMCwgdCkgb3AgPSBbb3BbMF0gJiAyLCB0LnZhbHVlXTtcbiAgICAgICAgICAgIHN3aXRjaCAob3BbMF0pIHtcbiAgICAgICAgICAgICAgICBjYXNlIDA6IGNhc2UgMTogdCA9IG9wOyBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDQ6IF8ubGFiZWwrKzsgcmV0dXJuIHsgdmFsdWU6IG9wWzFdLCBkb25lOiBmYWxzZSB9O1xuICAgICAgICAgICAgICAgIGNhc2UgNTogXy5sYWJlbCsrOyB5ID0gb3BbMV07IG9wID0gWzBdOyBjb250aW51ZTtcbiAgICAgICAgICAgICAgICBjYXNlIDc6IG9wID0gXy5vcHMucG9wKCk7IF8udHJ5cy5wb3AoKTsgY29udGludWU7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgaWYgKCEodCA9IF8udHJ5cywgdCA9IHQubGVuZ3RoID4gMCAmJiB0W3QubGVuZ3RoIC0gMV0pICYmIChvcFswXSA9PT0gNiB8fCBvcFswXSA9PT0gMikpIHsgXyA9IDA7IGNvbnRpbnVlOyB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChvcFswXSA9PT0gMyAmJiAoIXQgfHwgKG9wWzFdID4gdFswXSAmJiBvcFsxXSA8IHRbM10pKSkgeyBfLmxhYmVsID0gb3BbMV07IGJyZWFrOyB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChvcFswXSA9PT0gNiAmJiBfLmxhYmVsIDwgdFsxXSkgeyBfLmxhYmVsID0gdFsxXTsgdCA9IG9wOyBicmVhazsgfVxuICAgICAgICAgICAgICAgICAgICBpZiAodCAmJiBfLmxhYmVsIDwgdFsyXSkgeyBfLmxhYmVsID0gdFsyXTsgXy5vcHMucHVzaChvcCk7IGJyZWFrOyB9XG4gICAgICAgICAgICAgICAgICAgIGlmICh0WzJdKSBfLm9wcy5wb3AoKTtcbiAgICAgICAgICAgICAgICAgICAgXy50cnlzLnBvcCgpOyBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG9wID0gYm9keS5jYWxsKHRoaXNBcmcsIF8pO1xuICAgICAgICB9IGNhdGNoIChlKSB7IG9wID0gWzYsIGVdOyB5ID0gMDsgfSBmaW5hbGx5IHsgZiA9IHQgPSAwOyB9XG4gICAgICAgIGlmIChvcFswXSAmIDUpIHRocm93IG9wWzFdOyByZXR1cm4geyB2YWx1ZTogb3BbMF0gPyBvcFsxXSA6IHZvaWQgMCwgZG9uZTogdHJ1ZSB9O1xuICAgIH1cbn07XG4vLyBUT0RPOiB1c2UgQHRzLWV4cGVjdC1lcnJvclxuaW1wb3J0IHsgdXNlQ2FsbGJhY2ssIHVzZUNvbnRleHQsIHVzZVN0YXRlLCB1c2VSZWYsIHVzZU1lbW8sIHVzZURlYnVnVmFsdWUgfSBmcm9tICdyZWFjdCc7XG5pbXBvcnQgZGVmYXVsdENvbmZpZywgeyBjYWNoZSB9IGZyb20gJy4vY29uZmlnJztcbmltcG9ydCB7IElTX1NFUlZFUiwgckFGLCB1c2VJc29tb3JwaGljTGF5b3V0RWZmZWN0IH0gZnJvbSAnLi9lbnYnO1xuaW1wb3J0IFNXUkNvbmZpZ0NvbnRleHQgZnJvbSAnLi9zd3ItY29uZmlnLWNvbnRleHQnO1xuLy8gZ2xvYmFsIHN0YXRlIG1hbmFnZXJzXG52YXIgQ09OQ1VSUkVOVF9QUk9NSVNFUyA9IHt9O1xudmFyIENPTkNVUlJFTlRfUFJPTUlTRVNfVFMgPSB7fTtcbnZhciBGT0NVU19SRVZBTElEQVRPUlMgPSB7fTtcbnZhciBSRUNPTk5FQ1RfUkVWQUxJREFUT1JTID0ge307XG52YXIgQ0FDSEVfUkVWQUxJREFUT1JTID0ge307XG52YXIgTVVUQVRJT05fVFMgPSB7fTtcbnZhciBNVVRBVElPTl9FTkRfVFMgPSB7fTtcbi8vIGdlbmVyYXRlIHN0cmljdGx5IGluY3JlYXNpbmcgdGltZXN0YW1wc1xudmFyIG5vdyA9IChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHRzID0gMDtcbiAgICByZXR1cm4gZnVuY3Rpb24gKCkgeyByZXR1cm4gKyt0czsgfTtcbn0pKCk7XG4vLyBzZXR1cCBET00gZXZlbnRzIGxpc3RlbmVycyBmb3IgYGZvY3VzYCBhbmQgYHJlY29ubmVjdGAgYWN0aW9uc1xuaWYgKCFJU19TRVJWRVIpIHtcbiAgICB2YXIgcmV2YWxpZGF0ZV8xID0gZnVuY3Rpb24gKHJldmFsaWRhdG9ycykge1xuICAgICAgICBpZiAoIWRlZmF1bHRDb25maWcuaXNEb2N1bWVudFZpc2libGUoKSB8fCAhZGVmYXVsdENvbmZpZy5pc09ubGluZSgpKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBmb3IgKHZhciBrZXkgaW4gcmV2YWxpZGF0b3JzKSB7XG4gICAgICAgICAgICBpZiAocmV2YWxpZGF0b3JzW2tleV1bMF0pXG4gICAgICAgICAgICAgICAgcmV2YWxpZGF0b3JzW2tleV1bMF0oKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgaWYgKHR5cGVvZiBkZWZhdWx0Q29uZmlnLnJlZ2lzdGVyT25Gb2N1cyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBkZWZhdWx0Q29uZmlnLnJlZ2lzdGVyT25Gb2N1cyhmdW5jdGlvbiAoKSB7IHJldHVybiByZXZhbGlkYXRlXzEoRk9DVVNfUkVWQUxJREFUT1JTKTsgfSk7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgZGVmYXVsdENvbmZpZy5yZWdpc3Rlck9uUmVjb25uZWN0ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIGRlZmF1bHRDb25maWcucmVnaXN0ZXJPblJlY29ubmVjdChmdW5jdGlvbiAoKSB7IHJldHVybiByZXZhbGlkYXRlXzEoUkVDT05ORUNUX1JFVkFMSURBVE9SUyk7IH0pO1xuICAgIH1cbn1cbnZhciB0cmlnZ2VyID0gZnVuY3Rpb24gKF9rZXksIHNob3VsZFJldmFsaWRhdGUpIHtcbiAgICBpZiAoc2hvdWxkUmV2YWxpZGF0ZSA9PT0gdm9pZCAwKSB7IHNob3VsZFJldmFsaWRhdGUgPSB0cnVlOyB9XG4gICAgLy8gd2UgYXJlIGlnbm9yaW5nIHRoZSBzZWNvbmQgYXJndW1lbnQgd2hpY2ggY29ycmVzcG9uZCB0byB0aGUgYXJndW1lbnRzXG4gICAgLy8gdGhlIGZldGNoZXIgd2lsbCByZWNlaXZlIHdoZW4ga2V5IGlzIGFuIGFycmF5XG4gICAgdmFyIF9hID0gY2FjaGUuc2VyaWFsaXplS2V5KF9rZXkpLCBrZXkgPSBfYVswXSwga2V5RXJyID0gX2FbMl0sIGtleVZhbGlkYXRpbmcgPSBfYVszXTtcbiAgICBpZiAoIWtleSlcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpO1xuICAgIHZhciB1cGRhdGVycyA9IENBQ0hFX1JFVkFMSURBVE9SU1trZXldO1xuICAgIGlmIChrZXkgJiYgdXBkYXRlcnMpIHtcbiAgICAgICAgdmFyIGN1cnJlbnREYXRhID0gY2FjaGUuZ2V0KGtleSk7XG4gICAgICAgIHZhciBjdXJyZW50RXJyb3IgPSBjYWNoZS5nZXQoa2V5RXJyKTtcbiAgICAgICAgdmFyIGN1cnJlbnRJc1ZhbGlkYXRpbmcgPSBjYWNoZS5nZXQoa2V5VmFsaWRhdGluZyk7XG4gICAgICAgIHZhciBwcm9taXNlcyA9IFtdO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHVwZGF0ZXJzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICBwcm9taXNlcy5wdXNoKHVwZGF0ZXJzW2ldKHNob3VsZFJldmFsaWRhdGUsIGN1cnJlbnREYXRhLCBjdXJyZW50RXJyb3IsIGN1cnJlbnRJc1ZhbGlkYXRpbmcsIGkgPiAwKSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gcmV0dXJuIG5ldyB1cGRhdGVkIHZhbHVlXG4gICAgICAgIHJldHVybiBQcm9taXNlLmFsbChwcm9taXNlcykudGhlbihmdW5jdGlvbiAoKSB7IHJldHVybiBjYWNoZS5nZXQoa2V5KTsgfSk7XG4gICAgfVxuICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoY2FjaGUuZ2V0KGtleSkpO1xufTtcbnZhciBicm9hZGNhc3RTdGF0ZSA9IGZ1bmN0aW9uIChrZXksIGRhdGEsIGVycm9yLCBpc1ZhbGlkYXRpbmcpIHtcbiAgICB2YXIgdXBkYXRlcnMgPSBDQUNIRV9SRVZBTElEQVRPUlNba2V5XTtcbiAgICBpZiAoa2V5ICYmIHVwZGF0ZXJzKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdXBkYXRlcnMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgIHVwZGF0ZXJzW2ldKGZhbHNlLCBkYXRhLCBlcnJvciwgaXNWYWxpZGF0aW5nKTtcbiAgICAgICAgfVxuICAgIH1cbn07XG52YXIgbXV0YXRlID0gZnVuY3Rpb24gKF9rZXksIF9kYXRhLCBzaG91bGRSZXZhbGlkYXRlKSB7XG4gICAgaWYgKHNob3VsZFJldmFsaWRhdGUgPT09IHZvaWQgMCkgeyBzaG91bGRSZXZhbGlkYXRlID0gdHJ1ZTsgfVxuICAgIHJldHVybiBfX2F3YWl0ZXIodm9pZCAwLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX2EsIGtleSwga2V5RXJyLCBiZWZvcmVNdXRhdGlvblRzLCBiZWZvcmVDb25jdXJyZW50UHJvbWlzZXNUcywgZGF0YSwgZXJyb3IsIGlzQXN5bmNNdXRhdGlvbiwgZXJyXzEsIHNob3VsZEFib3J0LCB1cGRhdGVycywgcHJvbWlzZXMsIGk7XG4gICAgICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2IpIHtcbiAgICAgICAgICAgIHN3aXRjaCAoX2IubGFiZWwpIHtcbiAgICAgICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgICAgIF9hID0gY2FjaGUuc2VyaWFsaXplS2V5KF9rZXkpLCBrZXkgPSBfYVswXSwga2V5RXJyID0gX2FbMl07XG4gICAgICAgICAgICAgICAgICAgIGlmICgha2V5KVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi9dO1xuICAgICAgICAgICAgICAgICAgICAvLyBpZiB0aGVyZSBpcyBubyBuZXcgZGF0YSB0byB1cGRhdGUsIGxldCdzIGp1c3QgcmV2YWxpZGF0ZSB0aGUga2V5XG4gICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgX2RhdGEgPT09ICd1bmRlZmluZWQnKVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIHRyaWdnZXIoX2tleSwgc2hvdWxkUmV2YWxpZGF0ZSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyB1cGRhdGUgZ2xvYmFsIHRpbWVzdGFtcHNcbiAgICAgICAgICAgICAgICAgICAgICAgIF07XG4gICAgICAgICAgICAgICAgICAgIC8vIHVwZGF0ZSBnbG9iYWwgdGltZXN0YW1wc1xuICAgICAgICAgICAgICAgICAgICBNVVRBVElPTl9UU1trZXldID0gbm93KCkgLSAxO1xuICAgICAgICAgICAgICAgICAgICBNVVRBVElPTl9FTkRfVFNba2V5XSA9IDA7XG4gICAgICAgICAgICAgICAgICAgIGJlZm9yZU11dGF0aW9uVHMgPSBNVVRBVElPTl9UU1trZXldO1xuICAgICAgICAgICAgICAgICAgICBiZWZvcmVDb25jdXJyZW50UHJvbWlzZXNUcyA9IENPTkNVUlJFTlRfUFJPTUlTRVNfVFNba2V5XTtcbiAgICAgICAgICAgICAgICAgICAgaXNBc3luY011dGF0aW9uID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIGlmIChfZGF0YSAmJiB0eXBlb2YgX2RhdGEgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGBfZGF0YWAgaXMgYSBmdW5jdGlvbiwgY2FsbCBpdCBwYXNzaW5nIGN1cnJlbnQgY2FjaGUgdmFsdWVcbiAgICAgICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX2RhdGEgPSBfZGF0YShjYWNoZS5nZXQoa2V5KSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gaWYgYF9kYXRhYCBmdW5jdGlvbiB0aHJvd3MgYW4gZXJyb3Igc3luY2hyb25vdXNseSwgaXQgc2hvdWxkbid0IGJlIGNhY2hlZFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9kYXRhID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVycm9yID0gZXJyO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmICghKF9kYXRhICYmIHR5cGVvZiBfZGF0YS50aGVuID09PSAnZnVuY3Rpb24nKSkgcmV0dXJuIFszIC8qYnJlYWsqLywgNV07XG4gICAgICAgICAgICAgICAgICAgIC8vIGBfZGF0YWAgaXMgYSBwcm9taXNlXG4gICAgICAgICAgICAgICAgICAgIGlzQXN5bmNNdXRhdGlvbiA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIF9iLmxhYmVsID0gMTtcbiAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgIF9iLnRyeXMucHVzaChbMSwgMywgLCA0XSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCAvKnlpZWxkKi8sIF9kYXRhXTtcbiAgICAgICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgICAgIGRhdGEgPSBfYi5zZW50KCk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBbMyAvKmJyZWFrKi8sIDRdO1xuICAgICAgICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgICAgICAgICAgZXJyXzEgPSBfYi5zZW50KCk7XG4gICAgICAgICAgICAgICAgICAgIGVycm9yID0gZXJyXzE7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBbMyAvKmJyZWFrKi8sIDRdO1xuICAgICAgICAgICAgICAgIGNhc2UgNDogcmV0dXJuIFszIC8qYnJlYWsqLywgNl07XG4gICAgICAgICAgICAgICAgY2FzZSA1OlxuICAgICAgICAgICAgICAgICAgICBkYXRhID0gX2RhdGE7XG4gICAgICAgICAgICAgICAgICAgIF9iLmxhYmVsID0gNjtcbiAgICAgICAgICAgICAgICBjYXNlIDY6XG4gICAgICAgICAgICAgICAgICAgIHNob3VsZEFib3J0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gY2hlY2sgaWYgb3RoZXIgbXV0YXRpb25zIGhhdmUgb2NjdXJyZWQgc2luY2Ugd2UndmUgc3RhcnRlZCB0aGlzIG11dGF0aW9uXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoYmVmb3JlTXV0YXRpb25UcyAhPT0gTVVUQVRJT05fVFNba2V5XSB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJlZm9yZUNvbmN1cnJlbnRQcm9taXNlc1RzICE9PSBDT05DVVJSRU5UX1BST01JU0VTX1RTW2tleV0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZXJyb3IpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICAvLyBpZiB0aGVyZSdzIGEgcmFjZSB3ZSBkb24ndCB1cGRhdGUgY2FjaGUgb3IgYnJvYWRjYXN0IGNoYW5nZSwganVzdCByZXR1cm4gdGhlIGRhdGFcbiAgICAgICAgICAgICAgICAgICAgaWYgKHNob3VsZEFib3J0KCkpXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qLywgZGF0YV07XG4gICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgZGF0YSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHVwZGF0ZSBjYWNoZWQgZGF0YVxuICAgICAgICAgICAgICAgICAgICAgICAgY2FjaGUuc2V0KGtleSwgZGF0YSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgLy8gYWx3YXlzIHVwZGF0ZSBvciByZXNldCB0aGUgZXJyb3JcbiAgICAgICAgICAgICAgICAgICAgY2FjaGUuc2V0KGtleUVyciwgZXJyb3IpO1xuICAgICAgICAgICAgICAgICAgICAvLyByZXNldCB0aGUgdGltZXN0YW1wIHRvIG1hcmsgdGhlIG11dGF0aW9uIGhhcyBlbmRlZFxuICAgICAgICAgICAgICAgICAgICBNVVRBVElPTl9FTkRfVFNba2V5XSA9IG5vdygpIC0gMTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFpc0FzeW5jTXV0YXRpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHdlIHNraXAgYnJvYWRjYXN0aW5nIGlmIHRoZXJlJ3MgYW5vdGhlciBtdXRhdGlvbiBoYXBwZW5lZCBzeW5jaHJvbm91c2x5XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoc2hvdWxkQWJvcnQoKSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qLywgZGF0YV07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdXBkYXRlcnMgPSBDQUNIRV9SRVZBTElEQVRPUlNba2V5XTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHVwZGF0ZXJzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwcm9taXNlcyA9IFtdO1xuICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IHVwZGF0ZXJzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJvbWlzZXMucHVzaCh1cGRhdGVyc1tpXSghIXNob3VsZFJldmFsaWRhdGUsIGRhdGEsIGVycm9yLCB1bmRlZmluZWQsIGkgPiAwKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyByZXR1cm4gbmV3IHVwZGF0ZWQgdmFsdWVcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovLCBQcm9taXNlLmFsbChwcm9taXNlcykudGhlbihmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChlcnJvcilcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gY2FjaGUuZ2V0KGtleSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSldO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIC8vIHRocm93IGVycm9yIG9yIHJldHVybiBkYXRhIHRvIGJlIHVzZWQgYnkgY2FsbGVyIG9mIG11dGF0ZVxuICAgICAgICAgICAgICAgICAgICBpZiAoZXJyb3IpXG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIGRhdGFdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9KTtcbn07XG5mdW5jdGlvbiB1c2VTV1IoKSB7XG4gICAgdmFyIF90aGlzID0gdGhpcztcbiAgICB2YXIgYXJncyA9IFtdO1xuICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgIGFyZ3NbX2ldID0gYXJndW1lbnRzW19pXTtcbiAgICB9XG4gICAgdmFyIF9rZXkgPSBhcmdzWzBdO1xuICAgIHZhciBjb25maWcgPSBPYmplY3QuYXNzaWduKHt9LCBkZWZhdWx0Q29uZmlnLCB1c2VDb250ZXh0KFNXUkNvbmZpZ0NvbnRleHQpLCBhcmdzLmxlbmd0aCA+IDJcbiAgICAgICAgPyBhcmdzWzJdXG4gICAgICAgIDogYXJncy5sZW5ndGggPT09IDIgJiYgdHlwZW9mIGFyZ3NbMV0gPT09ICdvYmplY3QnXG4gICAgICAgICAgICA/IGFyZ3NbMV1cbiAgICAgICAgICAgIDoge30pO1xuICAgIC8vIGluIHR5cGVzY3JpcHQgYXJncy5sZW5ndGggPiAyIGlzIG5vdCBzYW1lIGFzIGFyZ3MubGVudGggPT09IDNcbiAgICAvLyB3ZSBkbyBhIHNhZmUgdHlwZSBhc3NlcnRpb24gaGVyZVxuICAgIC8vIGFyZ3MubGVuZ3RoID09PSAzXG4gICAgdmFyIGZuID0gKGFyZ3MubGVuZ3RoID4gMlxuICAgICAgICA/IGFyZ3NbMV1cbiAgICAgICAgOiBhcmdzLmxlbmd0aCA9PT0gMiAmJiB0eXBlb2YgYXJnc1sxXSA9PT0gJ2Z1bmN0aW9uJ1xuICAgICAgICAgICAgPyBhcmdzWzFdXG4gICAgICAgICAgICA6IC8qKlxuICAgICAgICAgICAgICAgICAgcGFzcyBmbiBhcyBudWxsIHdpbGwgZGlzYWJsZSByZXZhbGlkYXRlXG4gICAgICAgICAgICAgICAgICBodHRwczovL3BhY28uc2gvYmxvZy9zaGFyZWQtaG9vay1zdGF0ZS13aXRoLXN3clxuICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgYXJnc1sxXSA9PT0gbnVsbFxuICAgICAgICAgICAgICAgICAgICA/IGFyZ3NbMV1cbiAgICAgICAgICAgICAgICAgICAgOiBjb25maWcuZmV0Y2hlcik7XG4gICAgLy8gd2UgYXNzdW1lIGBrZXlgIGFzIHRoZSBpZGVudGlmaWVyIG9mIHRoZSByZXF1ZXN0XG4gICAgLy8gYGtleWAgY2FuIGNoYW5nZSBidXQgYGZuYCBzaG91bGRuJ3RcbiAgICAvLyAoYmVjYXVzZSBgcmV2YWxpZGF0ZWAgb25seSBkZXBlbmRzIG9uIGBrZXlgKVxuICAgIC8vIGBrZXlFcnJgIGlzIHRoZSBjYWNoZSBrZXkgZm9yIGVycm9yIG9iamVjdHNcbiAgICB2YXIgX2EgPSBjYWNoZS5zZXJpYWxpemVLZXkoX2tleSksIGtleSA9IF9hWzBdLCBmbkFyZ3MgPSBfYVsxXSwga2V5RXJyID0gX2FbMl0sIGtleVZhbGlkYXRpbmcgPSBfYVszXTtcbiAgICB2YXIgY29uZmlnUmVmID0gdXNlUmVmKGNvbmZpZyk7XG4gICAgdXNlSXNvbW9ycGhpY0xheW91dEVmZmVjdChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGNvbmZpZ1JlZi5jdXJyZW50ID0gY29uZmlnO1xuICAgIH0pO1xuICAgIHZhciB3aWxsUmV2YWxpZGF0ZU9uTW91bnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiAoY29uZmlnLnJldmFsaWRhdGVPbk1vdW50IHx8XG4gICAgICAgICAgICAoIWNvbmZpZy5pbml0aWFsRGF0YSAmJiBjb25maWcucmV2YWxpZGF0ZU9uTW91bnQgPT09IHVuZGVmaW5lZCkpO1xuICAgIH07XG4gICAgdmFyIHJlc29sdmVEYXRhID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgY2FjaGVkRGF0YSA9IGNhY2hlLmdldChrZXkpO1xuICAgICAgICByZXR1cm4gdHlwZW9mIGNhY2hlZERhdGEgPT09ICd1bmRlZmluZWQnID8gY29uZmlnLmluaXRpYWxEYXRhIDogY2FjaGVkRGF0YTtcbiAgICB9O1xuICAgIHZhciByZXNvbHZlSXNWYWxpZGF0aW5nID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gISFjYWNoZS5nZXQoa2V5VmFsaWRhdGluZykgfHwgKGtleSAmJiB3aWxsUmV2YWxpZGF0ZU9uTW91bnQoKSk7XG4gICAgfTtcbiAgICB2YXIgaW5pdGlhbERhdGEgPSByZXNvbHZlRGF0YSgpO1xuICAgIHZhciBpbml0aWFsRXJyb3IgPSBjYWNoZS5nZXQoa2V5RXJyKTtcbiAgICB2YXIgaW5pdGlhbElzVmFsaWRhdGluZyA9IHJlc29sdmVJc1ZhbGlkYXRpbmcoKTtcbiAgICAvLyBpZiBhIHN0YXRlIGlzIGFjY2Vzc2VkIChkYXRhLCBlcnJvciBvciBpc1ZhbGlkYXRpbmcpLFxuICAgIC8vIHdlIGFkZCB0aGUgc3RhdGUgdG8gZGVwZW5kZW5jaWVzIHNvIGlmIHRoZSBzdGF0ZSBpc1xuICAgIC8vIHVwZGF0ZWQgaW4gdGhlIGZ1dHVyZSwgd2UgY2FuIHRyaWdnZXIgYSByZXJlbmRlclxuICAgIHZhciBzdGF0ZURlcGVuZGVuY2llcyA9IHVzZVJlZih7XG4gICAgICAgIGRhdGE6IGZhbHNlLFxuICAgICAgICBlcnJvcjogZmFsc2UsXG4gICAgICAgIGlzVmFsaWRhdGluZzogZmFsc2VcbiAgICB9KTtcbiAgICB2YXIgc3RhdGVSZWYgPSB1c2VSZWYoe1xuICAgICAgICBkYXRhOiBpbml0aWFsRGF0YSxcbiAgICAgICAgZXJyb3I6IGluaXRpYWxFcnJvcixcbiAgICAgICAgaXNWYWxpZGF0aW5nOiBpbml0aWFsSXNWYWxpZGF0aW5nXG4gICAgfSk7XG4gICAgLy8gZGlzcGxheSB0aGUgZGF0YSBsYWJlbCBpbiB0aGUgUmVhY3QgRGV2VG9vbHMgbmV4dCB0byBTV1IgaG9va3NcbiAgICB1c2VEZWJ1Z1ZhbHVlKHN0YXRlUmVmLmN1cnJlbnQuZGF0YSk7XG4gICAgdmFyIHJlcmVuZGVyID0gdXNlU3RhdGUoe30pWzFdO1xuICAgIHZhciBkaXNwYXRjaCA9IHVzZUNhbGxiYWNrKGZ1bmN0aW9uIChwYXlsb2FkKSB7XG4gICAgICAgIHZhciBzaG91bGRVcGRhdGVTdGF0ZSA9IGZhbHNlO1xuICAgICAgICBmb3IgKHZhciBrIGluIHBheWxvYWQpIHtcbiAgICAgICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgICAgIGlmIChzdGF0ZVJlZi5jdXJyZW50W2tdID09PSBwYXlsb2FkW2tdKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgICAgICBzdGF0ZVJlZi5jdXJyZW50W2tdID0gcGF5bG9hZFtrXTtcbiAgICAgICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgICAgIGlmIChzdGF0ZURlcGVuZGVuY2llcy5jdXJyZW50W2tdKSB7XG4gICAgICAgICAgICAgICAgc2hvdWxkVXBkYXRlU3RhdGUgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChzaG91bGRVcGRhdGVTdGF0ZSkge1xuICAgICAgICAgICAgLy8gaWYgY29tcG9uZW50IGlzIHVubW91bnRlZCwgc2hvdWxkIHNraXAgcmVyZW5kZXJcbiAgICAgICAgICAgIC8vIGlmIGNvbXBvbmVudCBpcyBub3QgbW91bnRlZCwgc2hvdWxkIHNraXAgcmVyZW5kZXJcbiAgICAgICAgICAgIGlmICh1bm1vdW50ZWRSZWYuY3VycmVudCB8fCAhaW5pdGlhbE1vdW50ZWRSZWYuY3VycmVudClcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICByZXJlbmRlcih7fSk7XG4gICAgICAgIH1cbiAgICB9LCBcbiAgICAvLyBjb25maWcuc3VzcGVuc2UgaXNuJ3QgYWxsb3dlZCB0byBjaGFuZ2UgZHVyaW5nIHRoZSBsaWZlY3ljbGVcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3QtaG9va3MvZXhoYXVzdGl2ZS1kZXBzXG4gICAgW10pO1xuICAgIC8vIGVycm9yIHJlZiBpbnNpZGUgcmV2YWxpZGF0ZSAoaXMgbGFzdCByZXF1ZXN0IGVycm9yZWQ/KVxuICAgIHZhciB1bm1vdW50ZWRSZWYgPSB1c2VSZWYoZmFsc2UpO1xuICAgIHZhciBrZXlSZWYgPSB1c2VSZWYoa2V5KTtcbiAgICAvLyBjaGVjayBpZiBjb21wb25lbnQgaXMgbW91bnRlZCBpbiBzdXNwZW5zZSBtb2RlXG4gICAgdmFyIGluaXRpYWxNb3VudGVkUmVmID0gdXNlUmVmKGZhbHNlKTtcbiAgICAvLyBkbyB1bm1vdW50IGNoZWNrIGZvciBjYWxsYmFja3NcbiAgICB2YXIgZXZlbnRzQ2FsbGJhY2sgPSB1c2VDYWxsYmFjayhmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICB2YXIgcGFyYW1zID0gW107XG4gICAgICAgIGZvciAodmFyIF9pID0gMTsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICBwYXJhbXNbX2kgLSAxXSA9IGFyZ3VtZW50c1tfaV07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHVubW91bnRlZFJlZi5jdXJyZW50KVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBpZiAoIWluaXRpYWxNb3VudGVkUmVmLmN1cnJlbnQpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGlmIChrZXkgIT09IGtleVJlZi5jdXJyZW50KVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgIChfYSA9IGNvbmZpZ1JlZi5jdXJyZW50KVtldmVudF0uYXBwbHkoX2EsIHBhcmFtcyk7XG4gICAgfSwgW2tleV0pO1xuICAgIHZhciBib3VuZE11dGF0ZSA9IHVzZUNhbGxiYWNrKGZ1bmN0aW9uIChkYXRhLCBzaG91bGRSZXZhbGlkYXRlKSB7XG4gICAgICAgIHJldHVybiBtdXRhdGUoa2V5UmVmLmN1cnJlbnQsIGRhdGEsIHNob3VsZFJldmFsaWRhdGUpO1xuICAgIH0sIFtdKTtcbiAgICB2YXIgYWRkUmV2YWxpZGF0b3IgPSBmdW5jdGlvbiAocmV2YWxpZGF0b3JzLCBjYWxsYmFjaykge1xuICAgICAgICBpZiAoIXJldmFsaWRhdG9yc1trZXldKSB7XG4gICAgICAgICAgICByZXZhbGlkYXRvcnNba2V5XSA9IFtjYWxsYmFja107XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXZhbGlkYXRvcnNba2V5XS5wdXNoKGNhbGxiYWNrKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIGtleWVkUmV2YWxpZGF0b3JzID0gcmV2YWxpZGF0b3JzW2tleV07XG4gICAgICAgICAgICB2YXIgaW5kZXggPSBrZXllZFJldmFsaWRhdG9ycy5pbmRleE9mKGNhbGxiYWNrKTtcbiAgICAgICAgICAgIGlmIChpbmRleCA+PSAwKSB7XG4gICAgICAgICAgICAgICAgLy8gTygxKTogZmFzdGVyIHRoYW4gc3BsaWNlXG4gICAgICAgICAgICAgICAga2V5ZWRSZXZhbGlkYXRvcnNbaW5kZXhdID1cbiAgICAgICAgICAgICAgICAgICAga2V5ZWRSZXZhbGlkYXRvcnNba2V5ZWRSZXZhbGlkYXRvcnMubGVuZ3RoIC0gMV07XG4gICAgICAgICAgICAgICAga2V5ZWRSZXZhbGlkYXRvcnMucG9wKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgfTtcbiAgICAvLyBzdGFydCBhIHJldmFsaWRhdGlvblxuICAgIHZhciByZXZhbGlkYXRlID0gdXNlQ2FsbGJhY2soZnVuY3Rpb24gKHJldmFsaWRhdGVPcHRzKSB7XG4gICAgICAgIGlmIChyZXZhbGlkYXRlT3B0cyA9PT0gdm9pZCAwKSB7IHJldmFsaWRhdGVPcHRzID0ge307IH1cbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcihfdGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBfYSwgcmV0cnlDb3VudCwgX2IsIGRlZHVwZSwgbG9hZGluZywgc2hvdWxkRGVkdXBpbmcsIG5ld0RhdGEsIHN0YXJ0QXQsIG5ld1N0YXRlLCBlcnJfMjtcbiAgICAgICAgICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2MpIHtcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKF9jLmxhYmVsKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICgha2V5IHx8ICFmbilcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qLywgZmFsc2VdO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHVubW91bnRlZFJlZi5jdXJyZW50KVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovLCBmYWxzZV07XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoY29uZmlnUmVmLmN1cnJlbnQuaXNQYXVzZWQoKSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qLywgZmFsc2VdO1xuICAgICAgICAgICAgICAgICAgICAgICAgX2EgPSByZXZhbGlkYXRlT3B0cy5yZXRyeUNvdW50LCByZXRyeUNvdW50ID0gX2EgPT09IHZvaWQgMCA/IDAgOiBfYSwgX2IgPSByZXZhbGlkYXRlT3B0cy5kZWR1cGUsIGRlZHVwZSA9IF9iID09PSB2b2lkIDAgPyBmYWxzZSA6IF9iO1xuICAgICAgICAgICAgICAgICAgICAgICAgbG9hZGluZyA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICBzaG91bGREZWR1cGluZyA9IHR5cGVvZiBDT05DVVJSRU5UX1BST01JU0VTW2tleV0gIT09ICd1bmRlZmluZWQnICYmIGRlZHVwZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIF9jLmxhYmVsID0gMTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICAgICAgX2MudHJ5cy5wdXNoKFsxLCA2LCAsIDddKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRpc3BhdGNoKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpc1ZhbGlkYXRpbmc6IHRydWVcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FjaGUuc2V0KGtleVZhbGlkYXRpbmcsIHRydWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFzaG91bGREZWR1cGluZykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGFsc28gdXBkYXRlIG90aGVyIGhvb2tzXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJvYWRjYXN0U3RhdGUoa2V5LCBzdGF0ZVJlZi5jdXJyZW50LmRhdGEsIHN0YXRlUmVmLmN1cnJlbnQuZXJyb3IsIHRydWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgbmV3RGF0YSA9IHZvaWQgMDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YXJ0QXQgPSB2b2lkIDA7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIXNob3VsZERlZHVwaW5nKSByZXR1cm4gWzMgLypicmVhayovLCAzXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHRoZXJlJ3MgYWxyZWFkeSBhbiBvbmdvaW5nIHJlcXVlc3QsXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyB0aGlzIG9uZSBuZWVkcyB0byBiZSBkZWR1cGxpY2F0ZWQuXG4gICAgICAgICAgICAgICAgICAgICAgICBzdGFydEF0ID0gQ09OQ1VSUkVOVF9QUk9NSVNFU19UU1trZXldO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0IC8qeWllbGQqLywgQ09OQ1VSUkVOVF9QUk9NSVNFU1trZXldXTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgICAgICAgICAgbmV3RGF0YSA9IF9jLnNlbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMyAvKmJyZWFrKi8sIDVdO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBpZiBubyBjYWNoZSBiZWluZyByZW5kZXJlZCBjdXJyZW50bHkgKGl0IHNob3dzIGEgYmxhbmsgcGFnZSksXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyB3ZSB0cmlnZ2VyIHRoZSBsb2FkaW5nIHNsb3cgZXZlbnQuXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoY29uZmlnLmxvYWRpbmdUaW1lb3V0ICYmICFjYWNoZS5nZXQoa2V5KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAobG9hZGluZylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV2ZW50c0NhbGxiYWNrKCdvbkxvYWRpbmdTbG93Jywga2V5LCBjb25maWcpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sIGNvbmZpZy5sb2FkaW5nVGltZW91dCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZm5BcmdzICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgQ09OQ1VSUkVOVF9QUk9NSVNFU1trZXldID0gZm4uYXBwbHkodm9pZCAwLCBmbkFyZ3MpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgQ09OQ1VSUkVOVF9QUk9NSVNFU1trZXldID0gZm4oa2V5KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIENPTkNVUlJFTlRfUFJPTUlTRVNfVFNba2V5XSA9IHN0YXJ0QXQgPSBub3coKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCAvKnlpZWxkKi8sIENPTkNVUlJFTlRfUFJPTUlTRVNba2V5XV07XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgNDpcbiAgICAgICAgICAgICAgICAgICAgICAgIG5ld0RhdGEgPSBfYy5zZW50KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWxldGUgQ09OQ1VSUkVOVF9QUk9NSVNFU1trZXldO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlbGV0ZSBDT05DVVJSRU5UX1BST01JU0VTX1RTW2tleV07XG4gICAgICAgICAgICAgICAgICAgICAgICB9LCBjb25maWcuZGVkdXBpbmdJbnRlcnZhbCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyB0cmlnZ2VyIHRoZSBzdWNjZXNzIGV2ZW50LFxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gb25seSBkbyB0aGlzIGZvciB0aGUgb3JpZ2luYWwgcmVxdWVzdC5cbiAgICAgICAgICAgICAgICAgICAgICAgIGV2ZW50c0NhbGxiYWNrKCdvblN1Y2Nlc3MnLCBuZXdEYXRhLCBrZXksIGNvbmZpZyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBfYy5sYWJlbCA9IDU7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgNTpcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGlmIHRoZXJlJ3JlIG90aGVyIG9uZ29pbmcgcmVxdWVzdChzKSwgc3RhcnRlZCBhZnRlciB0aGUgY3VycmVudCBvbmUsXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyB3ZSBuZWVkIHRvIGlnbm9yZSB0aGUgY3VycmVudCBvbmUgdG8gYXZvaWQgcG9zc2libGUgcmFjZSBjb25kaXRpb25zOlxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gICByZXExLS0tLS0tLS0tLS0tLS0tLS0tPnJlczEgICAgICAgIChjdXJyZW50IG9uZSlcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vICAgICAgICByZXEyLS0tLS0tLS0tLS0tLS0tLT5yZXMyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyB0aGUgcmVxdWVzdCB0aGF0IGZpcmVkIGxhdGVyIHdpbGwgYWx3YXlzIGJlIGtlcHQuXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoQ09OQ1VSUkVOVF9QUk9NSVNFU19UU1trZXldID4gc3RhcnRBdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovLCBmYWxzZV07XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBpZiB0aGVyZSdyZSBvdGhlciBtdXRhdGlvbnMocyksIG92ZXJsYXBwZWQgd2l0aCB0aGUgY3VycmVudCByZXZhbGlkYXRpb246XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyAgIHJlcS0tLS0tLS0tLS0tLS0tLS0tLT5yZXNcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vICAgICAgIG11dGF0ZS0tLS0tLT5lbmRcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGNhc2UgMjpcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vICAgICAgICAgcmVxLS0tLS0tLS0tLS0tPnJlc1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gICBtdXRhdGUtLS0tLS0+ZW5kXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBjYXNlIDM6XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyAgIHJlcS0tLS0tLS0tLS0tLS0tLS0tLT5yZXNcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vICAgICAgIG11dGF0ZS0tLS0tLS0uLi4tLS0tLS0tLS0tPlxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gd2UgaGF2ZSB0byBpZ25vcmUgdGhlIHJldmFsaWRhdGlvbiByZXN1bHQgKHJlcykgYmVjYXVzZSBpdCdzIG5vIGxvbmdlciBmcmVzaC5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIG1lYW53aGlsZSwgYSBuZXcgcmV2YWxpZGF0aW9uIHNob3VsZCBiZSB0cmlnZ2VyZWQgd2hlbiB0aGUgbXV0YXRpb24gZW5kcy5cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChNVVRBVElPTl9UU1trZXldICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gY2FzZSAxXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKHN0YXJ0QXQgPD0gTVVUQVRJT05fVFNba2V5XSB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBjYXNlIDJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhcnRBdCA8PSBNVVRBVElPTl9FTkRfVFNba2V5XSB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBjYXNlIDNcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgTVVUQVRJT05fRU5EX1RTW2tleV0gPT09IDApKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGlzcGF0Y2goeyBpc1ZhbGlkYXRpbmc6IGZhbHNlIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovLCBmYWxzZV07XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBjYWNoZS5zZXQoa2V5RXJyLCB1bmRlZmluZWQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FjaGUuc2V0KGtleVZhbGlkYXRpbmcsIGZhbHNlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5ld1N0YXRlID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlzVmFsaWRhdGluZzogZmFsc2VcbiAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHN0YXRlUmVmLmN1cnJlbnQuZXJyb3IgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gd2UgZG9uJ3QgaGF2ZSBhbiBlcnJvclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5ld1N0YXRlLmVycm9yID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFjb25maWcuY29tcGFyZShzdGF0ZVJlZi5jdXJyZW50LmRhdGEsIG5ld0RhdGEpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gZGVlcCBjb21wYXJlIHRvIGF2b2lkIGV4dHJhIHJlLXJlbmRlclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGRhdGEgY2hhbmdlZFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5ld1N0YXRlLmRhdGEgPSBuZXdEYXRhO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFjb25maWcuY29tcGFyZShjYWNoZS5nZXQoa2V5KSwgbmV3RGF0YSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYWNoZS5zZXQoa2V5LCBuZXdEYXRhKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIG1lcmdlIHRoZSBuZXcgc3RhdGVcbiAgICAgICAgICAgICAgICAgICAgICAgIGRpc3BhdGNoKG5ld1N0YXRlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghc2hvdWxkRGVkdXBpbmcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBhbHNvIHVwZGF0ZSBvdGhlciBob29rc1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyb2FkY2FzdFN0YXRlKGtleSwgbmV3RGF0YSwgbmV3U3RhdGUuZXJyb3IsIGZhbHNlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMyAvKmJyZWFrKi8sIDddO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDY6XG4gICAgICAgICAgICAgICAgICAgICAgICBlcnJfMiA9IF9jLnNlbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlbGV0ZSBDT05DVVJSRU5UX1BST01JU0VTW2tleV07XG4gICAgICAgICAgICAgICAgICAgICAgICBkZWxldGUgQ09OQ1VSUkVOVF9QUk9NSVNFU19UU1trZXldO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNvbmZpZ1JlZi5jdXJyZW50LmlzUGF1c2VkKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkaXNwYXRjaCh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlzVmFsaWRhdGluZzogZmFsc2VcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qLywgZmFsc2VdO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgY2FjaGUuc2V0KGtleUVyciwgZXJyXzIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gZ2V0IGEgbmV3IGVycm9yXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBkb24ndCB1c2UgZGVlcCBlcXVhbCBmb3IgZXJyb3JzXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoc3RhdGVSZWYuY3VycmVudC5lcnJvciAhPT0gZXJyXzIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyB3ZSBrZWVwIHRoZSBzdGFsZSBkYXRhXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGlzcGF0Y2goe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpc1ZhbGlkYXRpbmc6IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlcnJvcjogZXJyXzJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIXNob3VsZERlZHVwaW5nKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGFsc28gYnJvYWRjYXN0IHRvIHVwZGF0ZSBvdGhlciBob29rc1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicm9hZGNhc3RTdGF0ZShrZXksIHVuZGVmaW5lZCwgZXJyXzIsIGZhbHNlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBldmVudHMgYW5kIHJldHJ5XG4gICAgICAgICAgICAgICAgICAgICAgICBldmVudHNDYWxsYmFjaygnb25FcnJvcicsIGVycl8yLCBrZXksIGNvbmZpZyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoY29uZmlnLnNob3VsZFJldHJ5T25FcnJvcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHdoZW4gcmV0cnlpbmcsIHdlIGFsd2F5cyBlbmFibGUgZGVkdXBpbmdcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBldmVudHNDYWxsYmFjaygnb25FcnJvclJldHJ5JywgZXJyXzIsIGtleSwgY29uZmlnLCByZXZhbGlkYXRlLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHJ5Q291bnQ6IHJldHJ5Q291bnQgKyAxLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWR1cGU6IHRydWVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMyAvKmJyZWFrKi8sIDddO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDc6XG4gICAgICAgICAgICAgICAgICAgICAgICBsb2FkaW5nID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qLywgdHJ1ZV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH0sIFxuICAgIC8vIGRpc3BhdGNoIGlzIGltbXV0YWJsZSwgYW5kIGBldmVudHNDYWxsYmFja2AsIGBmbkFyZ3NgLCBga2V5RXJyYCwgYW5kIGBrZXlWYWxpZGF0aW5nYCBhcmUgYmFzZWQgb24gYGtleWAsXG4gICAgLy8gc28gd2UgY2FuIHRoZW0gZnJvbSB0aGUgZGVwcyBhcnJheS5cbiAgICAvL1xuICAgIC8vIEZJWE1FOlxuICAgIC8vIGBmbmAgYW5kIGBjb25maWdgIG1pZ2h0IGJlIGNoYW5nZWQgZHVyaW5nIHRoZSBsaWZlY3ljbGUsXG4gICAgLy8gYnV0IHRoZXkgbWlnaHQgYmUgY2hhbmdlZCBldmVyeSByZW5kZXIgbGlrZSB0aGlzLlxuICAgIC8vIHVzZVNXUigna2V5JywgKCkgPT4gZmV0Y2goJy9hcGkvJyksIHsgc3VzcGVuc2U6IHRydWUgfSlcbiAgICAvLyBTbyB3ZSBvbWl0IHRoZSB2YWx1ZXMgZnJvbSB0aGUgZGVwcyBhcnJheVxuICAgIC8vIGV2ZW4gdGhvdWdoIGl0IG1pZ2h0IGNhdXNlIHVuZXhwZWN0ZWQgYmVoYXZpb3JzLlxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZWFjdC1ob29rcy9leGhhdXN0aXZlLWRlcHNcbiAgICBba2V5XSk7XG4gICAgLy8gbW91bnRlZCAoY2xpZW50IHNpZGUgcmVuZGVyaW5nKVxuICAgIHVzZUlzb21vcnBoaWNMYXlvdXRFZmZlY3QoZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoIWtleSlcbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgIC8vIGFmdGVyIGBrZXlgIHVwZGF0ZXMsIHdlIG5lZWQgdG8gbWFyayBpdCBhcyBtb3VudGVkXG4gICAgICAgIHVubW91bnRlZFJlZi5jdXJyZW50ID0gZmFsc2U7XG4gICAgICAgIHZhciBpc1VwZGF0aW5nID0gaW5pdGlhbE1vdW50ZWRSZWYuY3VycmVudDtcbiAgICAgICAgaW5pdGlhbE1vdW50ZWRSZWYuY3VycmVudCA9IHRydWU7XG4gICAgICAgIC8vIGFmdGVyIHRoZSBjb21wb25lbnQgaXMgbW91bnRlZCAoaHlkcmF0ZWQpLFxuICAgICAgICAvLyB3ZSBuZWVkIHRvIHVwZGF0ZSB0aGUgZGF0YSBmcm9tIHRoZSBjYWNoZVxuICAgICAgICAvLyBhbmQgdHJpZ2dlciBhIHJldmFsaWRhdGlvblxuICAgICAgICB2YXIgY3VycmVudEhvb2tEYXRhID0gc3RhdGVSZWYuY3VycmVudC5kYXRhO1xuICAgICAgICB2YXIgbGF0ZXN0S2V5ZWREYXRhID0gcmVzb2x2ZURhdGEoKTtcbiAgICAgICAgLy8gdXBkYXRlIHRoZSBzdGF0ZSBpZiB0aGUga2V5IGNoYW5nZWQgKG5vdCB0aGUgaW5pdGFsIHJlbmRlcikgb3IgY2FjaGUgdXBkYXRlZFxuICAgICAgICBrZXlSZWYuY3VycmVudCA9IGtleTtcbiAgICAgICAgaWYgKCFjb25maWcuY29tcGFyZShjdXJyZW50SG9va0RhdGEsIGxhdGVzdEtleWVkRGF0YSkpIHtcbiAgICAgICAgICAgIGRpc3BhdGNoKHsgZGF0YTogbGF0ZXN0S2V5ZWREYXRhIH0pO1xuICAgICAgICB9XG4gICAgICAgIC8vIHJldmFsaWRhdGUgd2l0aCBkZWR1cGluZ1xuICAgICAgICB2YXIgc29mdFJldmFsaWRhdGUgPSBmdW5jdGlvbiAoKSB7IHJldHVybiByZXZhbGlkYXRlKHsgZGVkdXBlOiB0cnVlIH0pOyB9O1xuICAgICAgICAvLyB0cmlnZ2VyIGEgcmV2YWxpZGF0aW9uXG4gICAgICAgIGlmIChpc1VwZGF0aW5nIHx8IHdpbGxSZXZhbGlkYXRlT25Nb3VudCgpKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIGxhdGVzdEtleWVkRGF0YSAhPT0gJ3VuZGVmaW5lZCcgJiYgIUlTX1NFUlZFUikge1xuICAgICAgICAgICAgICAgIC8vIGRlbGF5IHJldmFsaWRhdGUgaWYgdGhlcmUncyBjYWNoZVxuICAgICAgICAgICAgICAgIC8vIHRvIG5vdCBibG9jayB0aGUgcmVuZGVyaW5nXG4gICAgICAgICAgICAgICAgLy8gQHRzLWlnbm9yZSBpdCdzIHNhZmUgdG8gdXNlIHJlcXVlc3RBbmltYXRpb25GcmFtZSBpbiBicm93c2VyXG4gICAgICAgICAgICAgICAgckFGKHNvZnRSZXZhbGlkYXRlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHNvZnRSZXZhbGlkYXRlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHBlbmRpbmcgPSBmYWxzZTtcbiAgICAgICAgdmFyIG9uRm9jdXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAocGVuZGluZyB8fCAhY29uZmlnUmVmLmN1cnJlbnQucmV2YWxpZGF0ZU9uRm9jdXMpXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgcGVuZGluZyA9IHRydWU7XG4gICAgICAgICAgICBzb2Z0UmV2YWxpZGF0ZSgpO1xuICAgICAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7IHJldHVybiAocGVuZGluZyA9IGZhbHNlKTsgfSwgY29uZmlnUmVmLmN1cnJlbnQuZm9jdXNUaHJvdHRsZUludGVydmFsKTtcbiAgICAgICAgfTtcbiAgICAgICAgdmFyIG9uUmVjb25uZWN0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKGNvbmZpZ1JlZi5jdXJyZW50LnJldmFsaWRhdGVPblJlY29ubmVjdCkge1xuICAgICAgICAgICAgICAgIHNvZnRSZXZhbGlkYXRlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIC8vIHJlZ2lzdGVyIGdsb2JhbCBjYWNoZSB1cGRhdGUgbGlzdGVuZXJcbiAgICAgICAgdmFyIG9uVXBkYXRlID0gZnVuY3Rpb24gKHNob3VsZFJldmFsaWRhdGUsIHVwZGF0ZWREYXRhLCB1cGRhdGVkRXJyb3IsIHVwZGF0ZWRJc1ZhbGlkYXRpbmcsIGRlZHVwZSkge1xuICAgICAgICAgICAgaWYgKHNob3VsZFJldmFsaWRhdGUgPT09IHZvaWQgMCkgeyBzaG91bGRSZXZhbGlkYXRlID0gdHJ1ZTsgfVxuICAgICAgICAgICAgaWYgKGRlZHVwZSA9PT0gdm9pZCAwKSB7IGRlZHVwZSA9IHRydWU7IH1cbiAgICAgICAgICAgIC8vIHVwZGF0ZSBob29rIHN0YXRlXG4gICAgICAgICAgICB2YXIgbmV3U3RhdGUgPSB7fTtcbiAgICAgICAgICAgIHZhciBuZWVkVXBkYXRlID0gZmFsc2U7XG4gICAgICAgICAgICBpZiAodHlwZW9mIHVwZGF0ZWREYXRhICE9PSAndW5kZWZpbmVkJyAmJlxuICAgICAgICAgICAgICAgICFjb25maWcuY29tcGFyZShzdGF0ZVJlZi5jdXJyZW50LmRhdGEsIHVwZGF0ZWREYXRhKSkge1xuICAgICAgICAgICAgICAgIG5ld1N0YXRlLmRhdGEgPSB1cGRhdGVkRGF0YTtcbiAgICAgICAgICAgICAgICBuZWVkVXBkYXRlID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIGFsd2F5cyB1cGRhdGUgZXJyb3JcbiAgICAgICAgICAgIC8vIGJlY2F1c2UgaXQgY2FuIGJlIGB1bmRlZmluZWRgXG4gICAgICAgICAgICBpZiAoc3RhdGVSZWYuY3VycmVudC5lcnJvciAhPT0gdXBkYXRlZEVycm9yKSB7XG4gICAgICAgICAgICAgICAgbmV3U3RhdGUuZXJyb3IgPSB1cGRhdGVkRXJyb3I7XG4gICAgICAgICAgICAgICAgbmVlZFVwZGF0ZSA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodHlwZW9mIHVwZGF0ZWRJc1ZhbGlkYXRpbmcgIT09ICd1bmRlZmluZWQnICYmXG4gICAgICAgICAgICAgICAgc3RhdGVSZWYuY3VycmVudC5pc1ZhbGlkYXRpbmcgIT09IHVwZGF0ZWRJc1ZhbGlkYXRpbmcpIHtcbiAgICAgICAgICAgICAgICBuZXdTdGF0ZS5pc1ZhbGlkYXRpbmcgPSB1cGRhdGVkSXNWYWxpZGF0aW5nO1xuICAgICAgICAgICAgICAgIG5lZWRVcGRhdGUgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG5lZWRVcGRhdGUpIHtcbiAgICAgICAgICAgICAgICBkaXNwYXRjaChuZXdTdGF0ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoc2hvdWxkUmV2YWxpZGF0ZSkge1xuICAgICAgICAgICAgICAgIGlmIChkZWR1cGUpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHNvZnRSZXZhbGlkYXRlKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmV2YWxpZGF0ZSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfTtcbiAgICAgICAgdmFyIHVuc3ViRm9jdXMgPSBhZGRSZXZhbGlkYXRvcihGT0NVU19SRVZBTElEQVRPUlMsIG9uRm9jdXMpO1xuICAgICAgICB2YXIgdW5zdWJSZWNvbm5lY3QgPSBhZGRSZXZhbGlkYXRvcihSRUNPTk5FQ1RfUkVWQUxJREFUT1JTLCBvblJlY29ubmVjdCk7XG4gICAgICAgIHZhciB1bnN1YlVwZGF0ZSA9IGFkZFJldmFsaWRhdG9yKENBQ0hFX1JFVkFMSURBVE9SUywgb25VcGRhdGUpO1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgLy8gY2xlYW51cFxuICAgICAgICAgICAgZGlzcGF0Y2ggPSBmdW5jdGlvbiAoKSB7IHJldHVybiBudWxsOyB9O1xuICAgICAgICAgICAgLy8gbWFyayBpdCBhcyB1bm1vdW50ZWRcbiAgICAgICAgICAgIHVubW91bnRlZFJlZi5jdXJyZW50ID0gdHJ1ZTtcbiAgICAgICAgICAgIHVuc3ViRm9jdXMoKTtcbiAgICAgICAgICAgIHVuc3ViUmVjb25uZWN0KCk7XG4gICAgICAgICAgICB1bnN1YlVwZGF0ZSgpO1xuICAgICAgICB9O1xuICAgIH0sIFtrZXksIHJldmFsaWRhdGVdKTtcbiAgICB1c2VJc29tb3JwaGljTGF5b3V0RWZmZWN0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHRpbWVyID0gbnVsbDtcbiAgICAgICAgdmFyIHRpY2sgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBfX2F3YWl0ZXIoX3RoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgICAgICAgICAgc3dpdGNoIChfYS5sYWJlbCkge1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoISghc3RhdGVSZWYuY3VycmVudC5lcnJvciAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIChjb25maWdSZWYuY3VycmVudC5yZWZyZXNoV2hlbkhpZGRlbiB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25maWdSZWYuY3VycmVudC5pc0RvY3VtZW50VmlzaWJsZSgpKSAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIChjb25maWdSZWYuY3VycmVudC5yZWZyZXNoV2hlbk9mZmxpbmUgfHwgY29uZmlnUmVmLmN1cnJlbnQuaXNPbmxpbmUoKSkpKSByZXR1cm4gWzMgLypicmVhayovLCAyXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIG9ubHkgcmV2YWxpZGF0ZSB3aGVuIHRoZSBwYWdlIGlzIHZpc2libGVcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGlmIEFQSSByZXF1ZXN0IGVycm9yZWQsIHdlIHN0b3AgcG9sbGluZyBpbiB0aGlzIHJvdW5kXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBhbmQgbGV0IHRoZSBlcnJvciByZXRyeSBmdW5jdGlvbiBoYW5kbGUgaXRcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCAvKnlpZWxkKi8sIHJldmFsaWRhdGUoeyBkZWR1cGU6IHRydWUgfSldO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBvbmx5IHJldmFsaWRhdGUgd2hlbiB0aGUgcGFnZSBpcyB2aXNpYmxlXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBpZiBBUEkgcmVxdWVzdCBlcnJvcmVkLCB3ZSBzdG9wIHBvbGxpbmcgaW4gdGhpcyByb3VuZFxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gYW5kIGxldCB0aGUgZXJyb3IgcmV0cnkgZnVuY3Rpb24gaGFuZGxlIGl0XG4gICAgICAgICAgICAgICAgICAgICAgICBfYS5zZW50KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBfYS5sYWJlbCA9IDI7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFJlYWQgdGhlIGxhdGVzdCByZWZyZXNoSW50ZXJ2YWxcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjb25maWdSZWYuY3VycmVudC5yZWZyZXNoSW50ZXJ2YWwgJiYgdGltZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aW1lciA9IHNldFRpbWVvdXQodGljaywgY29uZmlnUmVmLmN1cnJlbnQucmVmcmVzaEludGVydmFsKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7IH07XG4gICAgICAgIGlmIChjb25maWdSZWYuY3VycmVudC5yZWZyZXNoSW50ZXJ2YWwpIHtcbiAgICAgICAgICAgIHRpbWVyID0gc2V0VGltZW91dCh0aWNrLCBjb25maWdSZWYuY3VycmVudC5yZWZyZXNoSW50ZXJ2YWwpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAodGltZXIpIHtcbiAgICAgICAgICAgICAgICBjbGVhclRpbWVvdXQodGltZXIpO1xuICAgICAgICAgICAgICAgIHRpbWVyID0gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICB9LCBbXG4gICAgICAgIGNvbmZpZy5yZWZyZXNoSW50ZXJ2YWwsXG4gICAgICAgIGNvbmZpZy5yZWZyZXNoV2hlbkhpZGRlbixcbiAgICAgICAgY29uZmlnLnJlZnJlc2hXaGVuT2ZmbGluZSxcbiAgICAgICAgcmV2YWxpZGF0ZVxuICAgIF0pO1xuICAgIC8vIHN1c3BlbnNlXG4gICAgdmFyIGxhdGVzdERhdGE7XG4gICAgdmFyIGxhdGVzdEVycm9yO1xuICAgIGlmIChjb25maWcuc3VzcGVuc2UpIHtcbiAgICAgICAgLy8gaW4gc3VzcGVuc2UgbW9kZSwgd2UgY2FuJ3QgcmV0dXJuIGVtcHR5IHN0YXRlXG4gICAgICAgIC8vIChpdCBzaG91bGQgYmUgc3VzcGVuZGVkKVxuICAgICAgICAvLyB0cnkgdG8gZ2V0IGRhdGEgYW5kIGVycm9yIGZyb20gY2FjaGVcbiAgICAgICAgbGF0ZXN0RGF0YSA9IGNhY2hlLmdldChrZXkpO1xuICAgICAgICBsYXRlc3RFcnJvciA9IGNhY2hlLmdldChrZXlFcnIpO1xuICAgICAgICBpZiAodHlwZW9mIGxhdGVzdERhdGEgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBsYXRlc3REYXRhID0gaW5pdGlhbERhdGE7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiBsYXRlc3RFcnJvciA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIGxhdGVzdEVycm9yID0gaW5pdGlhbEVycm9yO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgbGF0ZXN0RGF0YSA9PT0gJ3VuZGVmaW5lZCcgJiZcbiAgICAgICAgICAgIHR5cGVvZiBsYXRlc3RFcnJvciA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIC8vIG5lZWQgdG8gc3RhcnQgdGhlIHJlcXVlc3QgaWYgaXQgaGFzbid0XG4gICAgICAgICAgICBpZiAoIUNPTkNVUlJFTlRfUFJPTUlTRVNba2V5XSkge1xuICAgICAgICAgICAgICAgIC8vIHRyaWdnZXIgcmV2YWxpZGF0ZSBpbW1lZGlhdGVseVxuICAgICAgICAgICAgICAgIC8vIHRvIGdldCB0aGUgcHJvbWlzZVxuICAgICAgICAgICAgICAgIC8vIGluIHRoaXMgcmV2YWxpZGF0ZSwgc2hvdWxkIG5vdCByZXJlbmRlclxuICAgICAgICAgICAgICAgIHJldmFsaWRhdGUoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChDT05DVVJSRU5UX1BST01JU0VTW2tleV0gJiZcbiAgICAgICAgICAgICAgICB0eXBlb2YgQ09OQ1VSUkVOVF9QUk9NSVNFU1trZXldLnRoZW4gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICAvLyBpZiBpdCBpcyBhIHByb21pc2VcbiAgICAgICAgICAgICAgICB0aHJvdyBDT05DVVJSRU5UX1BST01JU0VTW2tleV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBpdCdzIGEgdmFsdWUsIHJldHVybiBpdCBkaXJlY3RseSAob3ZlcnJpZGUpXG4gICAgICAgICAgICBsYXRlc3REYXRhID0gQ09OQ1VSUkVOVF9QUk9NSVNFU1trZXldO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgbGF0ZXN0RGF0YSA9PT0gJ3VuZGVmaW5lZCcgJiYgbGF0ZXN0RXJyb3IpIHtcbiAgICAgICAgICAgIC8vIGluIHN1c3BlbnNlIG1vZGUsIHRocm93IGVycm9yIGlmIHRoZXJlJ3Mgbm8gY29udGVudFxuICAgICAgICAgICAgdGhyb3cgbGF0ZXN0RXJyb3I7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gZGVmaW5lIHJldHVybmVkIHN0YXRlXG4gICAgLy8gY2FuIGJlIG1lbW9yaXplZCBzaW5jZSB0aGUgc3RhdGUgaXMgYSByZWZcbiAgICB2YXIgbWVtb2l6ZWRTdGF0ZSA9IHVzZU1lbW8oZnVuY3Rpb24gKCkge1xuICAgICAgICAvLyByZXZhbGlkYXRlIHdpbGwgYmUgZGVwcmVjYXRlZCBpbiB0aGUgMS54IHJlbGVhc2VcbiAgICAgICAgLy8gYmVjYXVzZSBtdXRhdGUoKSBjb3ZlcnMgdGhlIHNhbWUgdXNlIGNhc2Ugb2YgcmV2YWxpZGF0ZSgpLlxuICAgICAgICAvLyBUaGlzIHJlbWFpbnMgb25seSBmb3IgYmFja3dhcmQgY29tcGF0aWJpbGl0eVxuICAgICAgICB2YXIgc3RhdGUgPSB7IHJldmFsaWRhdGU6IHJldmFsaWRhdGUsIG11dGF0ZTogYm91bmRNdXRhdGUgfTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoc3RhdGUsIHtcbiAgICAgICAgICAgIGVycm9yOiB7XG4gICAgICAgICAgICAgICAgLy8gYGtleWAgbWlnaHQgYmUgY2hhbmdlZCBpbiB0aGUgdXBjb21pbmcgaG9vayByZS1yZW5kZXIsXG4gICAgICAgICAgICAgICAgLy8gYnV0IHRoZSBwcmV2aW91cyBzdGF0ZSB3aWxsIHN0YXlcbiAgICAgICAgICAgICAgICAvLyBzbyB3ZSBuZWVkIHRvIG1hdGNoIHRoZSBsYXRlc3Qga2V5IGFuZCBkYXRhIChmYWxsYmFjayB0byBgaW5pdGlhbERhdGFgKVxuICAgICAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICBzdGF0ZURlcGVuZGVuY2llcy5jdXJyZW50LmVycm9yID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNvbmZpZy5zdXNwZW5zZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGxhdGVzdEVycm9yO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBrZXlSZWYuY3VycmVudCA9PT0ga2V5ID8gc3RhdGVSZWYuY3VycmVudC5lcnJvciA6IGluaXRpYWxFcnJvcjtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWVcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBkYXRhOiB7XG4gICAgICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIHN0YXRlRGVwZW5kZW5jaWVzLmN1cnJlbnQuZGF0YSA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjb25maWcuc3VzcGVuc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBsYXRlc3REYXRhO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBrZXlSZWYuY3VycmVudCA9PT0ga2V5ID8gc3RhdGVSZWYuY3VycmVudC5kYXRhIDogaW5pdGlhbERhdGE7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgaXNWYWxpZGF0aW5nOiB7XG4gICAgICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIHN0YXRlRGVwZW5kZW5jaWVzLmN1cnJlbnQuaXNWYWxpZGF0aW5nID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGtleSA/IHN0YXRlUmVmLmN1cnJlbnQuaXNWYWxpZGF0aW5nIDogZmFsc2U7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlXG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gc3RhdGU7XG4gICAgICAgIC8vIGBjb25maWcuc3VzcGVuc2VgIGlzbid0IGFsbG93ZWQgdG8gY2hhbmdlIGR1cmluZyB0aGUgbGlmZWN5Y2xlLlxuICAgICAgICAvLyBgYm91bmRNdXRhdGVgIGlzIGltbXV0YWJsZSwgYW5kIHRoZSBpbW11dGFiaWxpdHkgb2YgYHJldmFsaWRhdGVgIGRlcGVuZHMgb24gYGtleWBcbiAgICAgICAgLy8gc28gd2UgY2FuIG9taXQgdGhlbSBmcm9tIHRoZSBkZXBzIGFycmF5LFxuICAgICAgICAvLyBidXQgd2UgcHV0IGl0IHRvIGVuYWJsZSByZWFjdC1ob29rcy9leGhhdXN0aXZlLWRlcHMgcnVsZS5cbiAgICAgICAgLy8gYGluaXRpYWxEYXRhYCBhbmQgYGluaXRpYWxFcnJvcmAgYXJlIG5vdCBpbml0aWFsIHZhbHVlc1xuICAgICAgICAvLyBiZWNhdXNlIHRoZXkgYXJlIGNoYW5nZWQgZHVyaW5nIHRoZSBsaWZlY3ljbGVcbiAgICAgICAgLy8gc28gd2Ugc2hvdWxkIGFkZCB0aGVtIGluIHRoZSBkZXBzIGFycmF5LlxuICAgIH0sIFtcbiAgICAgICAgcmV2YWxpZGF0ZSxcbiAgICAgICAgaW5pdGlhbERhdGEsXG4gICAgICAgIGluaXRpYWxFcnJvcixcbiAgICAgICAgYm91bmRNdXRhdGUsXG4gICAgICAgIGtleSxcbiAgICAgICAgY29uZmlnLnN1c3BlbnNlLFxuICAgICAgICBsYXRlc3RFcnJvcixcbiAgICAgICAgbGF0ZXN0RGF0YVxuICAgIF0pO1xuICAgIHJldHVybiBtZW1vaXplZFN0YXRlO1xufVxuT2JqZWN0LmRlZmluZVByb3BlcnR5KFNXUkNvbmZpZ0NvbnRleHQuUHJvdmlkZXIsICdkZWZhdWx0Jywge1xuICAgIHZhbHVlOiBkZWZhdWx0Q29uZmlnXG59KTtcbnZhciBTV1JDb25maWcgPSBTV1JDb25maWdDb250ZXh0LlByb3ZpZGVyO1xuZXhwb3J0IHsgdHJpZ2dlciwgbXV0YXRlLCBTV1JDb25maWcgfTtcbmV4cG9ydCBkZWZhdWx0IHVzZVNXUjtcbiIsImltcG9ydCB7IEZyYWdtZW50IH0gZnJvbSAncmVhY3QnXHJcbmltcG9ydCB7IHVzZVJvdXRlciB9IGZyb20gJ25leHQvcm91dGVyJ1xyXG5pbXBvcnQgdXNlU1dSIGZyb20gJ3N3cidcclxuXHJcbmltcG9ydCB7IGdldEZpbHRlcmVkRXZlbnRzIH0gZnJvbSAnLi4vLi4vaGVscGVycy9hcGktdXRpbHMnXHJcbmltcG9ydCBFdmVudExpc3QgZnJvbSAnLi4vLi4vY29tcG9uZW50cy9ldmVudHMvZXZlbnQtbGlzdCdcclxuaW1wb3J0IFJlc3VsdHNUaXRsZSBmcm9tICcuLi8uLi9jb21wb25lbnRzL3Jlc3VsdHMtdGl0bGUvcmVzdWx0cy10aXRsZSdcclxuaW1wb3J0IEJ1dHRvbiBmcm9tICcuLi8uLi9jb21wb25lbnRzL3VpL2J1dHRvbidcclxuaW1wb3J0IEVycm9yQWxlcnQgZnJvbSAnLi4vLi4vY29tcG9uZW50cy9lcnJvci1hbGVydC9lcnJvci1hbGVydCdcclxuXHJcbmZ1bmN0aW9uIEZpbHRlcmVkRXZlbnRzUGFnZShwcm9wcykge1xyXG4gIGNvbnN0IHJvdXRlciA9IHVzZVJvdXRlcigpXHJcblxyXG4gIGNvbnN0IGZpbHRlckRhdGEgPSByb3V0ZXIucXVlcnkuc2x1Z1xyXG5cclxuICBpZiAoIWZpbHRlckRhdGEpIHtcclxuICAgIHJldHVybiA8cCBjbGFzc05hbWU9J2NlbnRlcic+TG9hZGluZy4uLjwvcD5cclxuICB9XHJcblxyXG4gIGNvbnN0IGZpbHRlcmVkWWVhciA9IGZpbHRlckRhdGFbMF1cclxuICBjb25zdCBmaWx0ZXJlZE1vbnRoID0gZmlsdGVyRGF0YVsxXVxyXG5cclxuICBjb25zdCBudW1ZZWFyID0gK2ZpbHRlcmVkWWVhclxyXG4gIGNvbnN0IG51bU1vbnRoID0gK2ZpbHRlcmVkTW9udGhcclxuXHJcbiAgaWYgKHByb3BzLmhhc0Vycm9yKSB7XHJcbiAgICByZXR1cm4gKFxyXG4gICAgICA8RnJhZ21lbnQ+XHJcbiAgICAgICAgPEVycm9yQWxlcnQ+XHJcbiAgICAgICAgICBJbnZhbGlkIGZpbHRlci4gRXJyb3JBbGVydGxlYXNlIGFkanVzdCB5b3VyIHZhbHVlcyFcclxuICAgICAgICA8L0Vycm9yQWxlcnQ+XHJcbiAgICAgICAgPGRpdiBjbGFzc05hbWU9J2NlbnRlcic+XHJcbiAgICAgICAgICA8QnV0dG9uIGxpbms9Jy9ldmVudHMnPlNob3cgQWxsIEV2ZW50czwvQnV0dG9uPlxyXG4gICAgICAgIDwvZGl2PlxyXG4gICAgICA8L0ZyYWdtZW50PlxyXG4gICAgKVxyXG4gIH1cclxuXHJcbiAgY29uc3QgZmlsdGVyZWRFdmVudHMgPSBwcm9wcy5ldmVudHNcclxuXHJcbiAgaWYgKCFmaWx0ZXJlZEV2ZW50cyB8fCBmaWx0ZXJlZEV2ZW50cy5sZW5ndGggPT09IDApIHtcclxuICAgIHJldHVybiAoXHJcbiAgICAgIDxGcmFnbWVudD5cclxuICAgICAgICA8RXJyb3JBbGVydD5ObyBldmVudHMgZm91bmQgZm9yIHRoZSBjaG9zZW4gZmlsdGVyITwvRXJyb3JBbGVydD5cclxuICAgICAgPC9GcmFnbWVudD5cclxuICAgIClcclxuICB9XHJcblxyXG4gIGNvbnN0IGRhdGUgPSBuZXcgRGF0ZShwcm9wcy5kYXRlLnllYXIsIHByb3BzLmRhdGUubW9udGggLSAxKVxyXG5cclxuICByZXR1cm4gKFxyXG4gICAgPEZyYWdtZW50PlxyXG4gICAgICA8UmVzdWx0c1RpdGxlIGRhdGU9e2RhdGV9IC8+XHJcbiAgICAgIDxFdmVudExpc3QgaXRlbXM9e2ZpbHRlcmVkRXZlbnRzfSAvPlxyXG4gICAgPC9GcmFnbWVudD5cclxuICApXHJcbn1cclxuXHJcbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBnZXRTZXJ2ZXJTaWRlUHJvcHMoY29udGV4dCkge1xyXG4gIGNvbnN0IHsgcGFyYW1zIH0gPSBjb250ZXh0XHJcblxyXG4gIGNvbnN0IGZpbHRlckRhdGEgPSBwYXJhbXMuc2x1Z1xyXG5cclxuICBjb25zdCBmaWx0ZXJlZFllYXIgPSBmaWx0ZXJEYXRhWzBdXHJcbiAgY29uc3QgZmlsdGVyZWRNb250aCA9IGZpbHRlckRhdGFbMV1cclxuXHJcbiAgY29uc3QgbnVtWWVhciA9ICtmaWx0ZXJlZFllYXJcclxuICBjb25zdCBudW1Nb250aCA9ICtmaWx0ZXJlZE1vbnRoXHJcblxyXG4gIGlmIChcclxuICAgIGlzTmFOKG51bVllYXIpIHx8XHJcbiAgICBpc05hTihudW1Nb250aCkgfHxcclxuICAgIG51bVllYXIgPiAyMDMwIHx8XHJcbiAgICBudW1ZZWFyIDwgMjAyMSB8fFxyXG4gICAgbnVtTW9udGggPCAxIHx8XHJcbiAgICBudW1Nb250aCA+IDEyXHJcbiAgKSB7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICBwcm9wczogeyBoYXNFcnJvcjogdHJ1ZSB9XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBjb25zdCBmaWx0ZXJlZEV2ZW50cyA9IGF3YWl0IGdldEZpbHRlcmVkRXZlbnRzKHtcclxuICAgIHllYXI6IG51bVllYXIsXHJcbiAgICBtb250aDogbnVtTW9udGhcclxuICB9KVxyXG5cclxuICByZXR1cm4ge1xyXG4gICAgcHJvcHM6IHtcclxuICAgICAgZXZlbnRzOiBmaWx0ZXJlZEV2ZW50cyxcclxuICAgICAgZGF0ZToge1xyXG4gICAgICAgIHllYXI6IG51bVllYXIsXHJcbiAgICAgICAgbW9udGg6IG51bU1vbnRoXHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9XHJcbn1cclxuZXhwb3J0IGRlZmF1bHQgRmlsdGVyZWRFdmVudHNQYWdlXHJcbiJdLCJzb3VyY2VSb290IjoiIn0=